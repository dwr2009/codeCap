/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf 17337 2009-01-01 14:28:29Z magfr $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "system.h"
#include "subagent.h"
#include <SharedPtr.h>
#include <DBusMessage.h>
#include <DbusConnection.h>
#include <WebBrowserAppDef.h>
#include <Base64.h>
#include <StackBufString.h>
#include <ByteArray2.h>
#include <DbgLogSwitchDef.h>
#include <ctype.h>

#ifdef	SRC_FILE_NAME
#undef	SRC_FILE_NAME
#endif	//SRC_FILE_NAME
#define	SRC_FILE_NAME			"system.cpp"

using namespace CppBase;

static const oid audioOutputMode_oid[] = { 1,3,6,1,4,1,38010,3,5,42 };
static const oid snmpCommunity_oid[] = { 1, 3, 6, 1, 4, 1, 38010, 3, 5, 43 };
static const oid dispOsdResolutionId_oid[] = { 1, 3, 6, 1, 4, 1, 38010, 3, 5, 44 };
static const oid cpuSerialNo_oid[] = { 1, 3, 6, 1, 4, 1, 38010, 3, 5, 45 };
static const oid IrOut_oid[] = { 1, 3, 6, 1, 4, 1, 38010, 3, 5, 46 };
static const oid touchScreenCalibrate_oid[] = { 1, 3, 6, 1, 4, 1, 38010, 3, 5, 47 };
static const oid HdmiCecCtrl_oid[] = { 1, 3, 6, 1, 4, 1, 38010, 3, 5, 48 };
static const oid IrLevelOut_oid[] = { 1, 3, 6, 1, 4, 1, 38010, 3, 5, 49 };
// add by bert 2016/08/27
static const oid hardwareCapability_oid[] = { 1, 3, 6, 1, 4, 1, 38010, 3, 5, 51 };

/** Initializes the system module */
void
init_system(void)
{
	int iRet;
	
    const oid       cardCurrentStatus_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 5, 1 };
    const oid       currentClockTicks_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 5, 2 };
    const oid       mediaKey_oid[] = { 1, 3, 6, 1, 4, 1, 38010, 3, 5, 3 };
    const oid       formatMedia_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 5, 4 };
    const oid       scanMedia_oid[] = { 1, 3, 6, 1, 4, 1, 38010, 3, 5, 5 };
    const oid       mediaStatus_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 5, 6 };
    const oid       rebootSystem_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 5, 7 };
    const oid       firmwareUpgradeAddress_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 5, 8 };
    const oid       autoAnnounce_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 5, 9 };
    const oid       communicationProtocol_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 5, 10 };
    const oid       configSave_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 5, 11 };
    const oid       configSaveOption_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 5, 12 };
    const oid       tnetVersion_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 5, 13 };
    const oid       selfTest_oid[] = { 1, 3, 6, 1, 4, 1, 38010, 3, 5, 14 };
    const oid       priTimeServer_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 5, 15 };
    const oid       secTimeServer_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 5, 16 };
    const oid       timeZone_oid[] = { 1, 3, 6, 1, 4, 1, 38010, 3, 5, 17 };
    const oid       pushConfig_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 5, 18 };
    const oid       pullConfig_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 5, 19 };
    const oid       restorePreviousConfiguration_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 5, 20 };
    const oid       transferLog_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 5, 21 };
    const oid       softwareUpgradeAddress_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 5, 22 };
    const oid       userOSDAddress_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 5, 23 };
    const oid       deviceKey_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 5, 24 };
    const oid       enabledFeatures_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 5, 25 };
    const oid       maintainLog_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 5, 26 };
    const oid       irControl_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 5, 27 };
    const oid       trapEnable_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 5, 28 };
    const oid       trapReceiverAddress_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 5, 29 };
    const oid       webAdminPassword_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 5, 30 };
    const oid       snmpV3Only_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 5, 31 };
    const oid       multipleUpgradeAddress_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 5, 32 };
    const oid       gpioInterruptSource_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 5, 33 };
    const oid       configDateTime_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 5, 34 };
    const oid       loggingEnable_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 5, 35 };
    const oid       xappVersion_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 5, 36 };
    const oid       systemUpgradeAddress_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 5, 37 };
    const oid       autoReboot_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 5, 38 };
    const oid       autoRebootInterval_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 5, 39 };
    const oid       enableAudio6Ch_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 5, 50 };

    DEBUGMSGTL(("system", "Initializing\n"));

    iRet = netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("cardCurrentStatus", handle_cardCurrentStatus,
                             cardCurrentStatus_oid,
                             OID_LENGTH(cardCurrentStatus_oid),
                             HANDLER_CAN_RONLY));
	if(MIB_REGISTERED_OK != iRet)
	{
		DEBUGMSGTL(("SnmpAgent", "[%s:%d]Ret=%d\n", SRC_FILE_NAME, __LINE__, iRet));
	}
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("currentClockTicks", handle_currentClockTicks,
                             currentClockTicks_oid,
                             OID_LENGTH(currentClockTicks_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("mediaKey", handle_mediaKey, mediaKey_oid,
                             OID_LENGTH(mediaKey_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("formatMedia", handle_formatMedia,
                             formatMedia_oid, OID_LENGTH(formatMedia_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("scanMedia", handle_scanMedia, scanMedia_oid,
                             OID_LENGTH(scanMedia_oid),
                             HANDLER_CAN_RWRITE));
    iRet = netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("mediaStatus", handle_mediaStatus,
                             mediaStatus_oid, OID_LENGTH(mediaStatus_oid),
                             HANDLER_CAN_RONLY));
	if(MIB_REGISTERED_OK != iRet)
	{
		DEBUGMSGTL(("SnmpAgent", "[%s:%d]Ret=%d\n", SRC_FILE_NAME, __LINE__, iRet));
	}
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("rebootSystem", handle_rebootSystem,
                             rebootSystem_oid,
                             OID_LENGTH(rebootSystem_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("firmwareUpgradeAddress",
                             handle_firmwareUpgradeAddress,
                             firmwareUpgradeAddress_oid,
                             OID_LENGTH(firmwareUpgradeAddress_oid),
                             HANDLER_CAN_RWRITE));
    iRet = netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("autoAnnounce", handle_autoAnnounce,
                             autoAnnounce_oid,
                             OID_LENGTH(autoAnnounce_oid),
                             HANDLER_CAN_RWRITE));
	if(MIB_REGISTERED_OK != iRet)
	{
		DEBUGMSGTL(("SnmpAgent", "[%s:%d]Ret=%d\n", SRC_FILE_NAME, __LINE__, iRet));
	}
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("communicationProtocol",
                             handle_communicationProtocol,
                             communicationProtocol_oid,
                             OID_LENGTH(communicationProtocol_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("configSave", handle_configSave,
                             configSave_oid, OID_LENGTH(configSave_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("configSaveOption", handle_configSaveOption,
                             configSaveOption_oid,
                             OID_LENGTH(configSaveOption_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("tnetVersion", handle_tnetVersion,
                             tnetVersion_oid, OID_LENGTH(tnetVersion_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("selfTest", handle_selfTest, selfTest_oid,
                             OID_LENGTH(selfTest_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("priTimeServer", handle_priTimeServer,
                             priTimeServer_oid,
                             OID_LENGTH(priTimeServer_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("secTimeServer", handle_secTimeServer,
                             secTimeServer_oid,
                             OID_LENGTH(secTimeServer_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("timeZone", handle_timeZone, timeZone_oid,
                             OID_LENGTH(timeZone_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("pushConfig", handle_pushConfig,
                             pushConfig_oid, OID_LENGTH(pushConfig_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("pullConfig", handle_pullConfig,
                             pullConfig_oid, OID_LENGTH(pullConfig_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("restorePreviousConfiguration",
                             handle_restorePreviousConfiguration,
                             restorePreviousConfiguration_oid,
                             OID_LENGTH(restorePreviousConfiguration_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("transferLog", handle_transferLog,
                             transferLog_oid, OID_LENGTH(transferLog_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("softwareUpgradeAddress",
                             handle_softwareUpgradeAddress,
                             softwareUpgradeAddress_oid,
                             OID_LENGTH(softwareUpgradeAddress_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("userOSDAddress", handle_userOSDAddress,
                             userOSDAddress_oid,
                             OID_LENGTH(userOSDAddress_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("deviceKey", handle_deviceKey, deviceKey_oid,
                             OID_LENGTH(deviceKey_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("enabledFeatures", handle_enabledFeatures,
                             enabledFeatures_oid,
                             OID_LENGTH(enabledFeatures_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("maintainLog", handle_maintainLog,
                             maintainLog_oid, OID_LENGTH(maintainLog_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("irControl", handle_irControl, irControl_oid,
                             OID_LENGTH(irControl_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("trapEnable", handle_trapEnable,
                             trapEnable_oid, OID_LENGTH(trapEnable_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("trapReceiverAddress",
                             handle_trapReceiverAddress,
                             trapReceiverAddress_oid,
                             OID_LENGTH(trapReceiverAddress_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("webAdminPassword", handle_webAdminPassword,
                             webAdminPassword_oid,
                             OID_LENGTH(webAdminPassword_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("snmpV3Only", handle_snmpV3Only,
                             snmpV3Only_oid, OID_LENGTH(snmpV3Only_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("multipleUpgradeAddress",
                             handle_multipleUpgradeAddress,
                             multipleUpgradeAddress_oid,
                             OID_LENGTH(multipleUpgradeAddress_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("gpioInterruptSource",
                             handle_gpioInterruptSource,
                             gpioInterruptSource_oid,
                             OID_LENGTH(gpioInterruptSource_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("configDateTime", handle_configDateTime,
                             configDateTime_oid,
                             OID_LENGTH(configDateTime_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("loggingEnable", handle_loggingEnable,
                             loggingEnable_oid,
                             OID_LENGTH(loggingEnable_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("xappVersion", handle_xappVersion,
                             xappVersion_oid, OID_LENGTH(xappVersion_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("systemUpgradeAddress",
                             handle_systemUpgradeAddress,
                             systemUpgradeAddress_oid,
                             OID_LENGTH(systemUpgradeAddress_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("autoReboot", handle_autoReboot,
                             autoReboot_oid, OID_LENGTH(autoReboot_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("autoRebootInterval",
                             handle_autoRebootInterval,
                             autoRebootInterval_oid,
                             OID_LENGTH(autoRebootInterval_oid),
                             HANDLER_CAN_RWRITE));
	iRet = netsnmp_register_scalar(netsnmp_create_handler_registration("", handle_audioOutputMode, audioOutputMode_oid,
		OID_LENGTH(audioOutputMode_oid), HANDLER_CAN_RWRITE));
	if(MIB_REGISTERED_OK != iRet)
	{
		DEBUGMSGTL(("SnmpAgent", "[%s:%d]Ret=%d\n", SRC_FILE_NAME, __LINE__, iRet));
	}

    iRet = netsnmp_register_scalar(netsnmp_create_handler_registration
                                   ("snmpCommunity",
                                    handle_snmpCommunity,
                                    snmpCommunity_oid,
                                    OID_LENGTH(snmpCommunity_oid),
                                    HANDLER_CAN_RWRITE));
    if (MIB_REGISTERED_OK != iRet) {
        DEBUGMSGTL(("SnmpAgent", "[%s:%d]Ret=%d\n", SRC_FILE_NAME, __LINE__, iRet));
    }

    iRet = netsnmp_register_scalar(netsnmp_create_handler_registration
                                   ("dispOsdResolutionId",
                                    handle_dispOsdResolutionId,
                                    dispOsdResolutionId_oid,
                                    OID_LENGTH(dispOsdResolutionId_oid),
                                    HANDLER_CAN_RWRITE));
    if (MIB_REGISTERED_OK != iRet) {
        DEBUGMSGTL(("SnmpAgent", "[%s:%d]Ret=%d\n", SRC_FILE_NAME, __LINE__, iRet));
    }

    iRet = netsnmp_register_scalar(netsnmp_create_handler_registration
                                   ("cpuSerialNo",
                                    handle_cpuSerialNo,
                                    cpuSerialNo_oid,
                                    OID_LENGTH(cpuSerialNo_oid),
                                    HANDLER_CAN_RONLY));
    if (MIB_REGISTERED_OK != iRet) {
        DEBUGMSGTL(("SnmpAgent", "[%s:%d]Ret=%d\n", SRC_FILE_NAME, __LINE__, iRet));
    }

#if 1 //add by bert 2016/08/27
    iRet = netsnmp_register_scalar(netsnmp_create_handler_registration
                                   ("hardwareCapability",
                                    handle_hardwareCapability,
                                    hardwareCapability_oid,
                                    OID_LENGTH(hardwareCapability_oid),
                                    HANDLER_CAN_RONLY));
    if (MIB_REGISTERED_OK != iRet) {
        DEBUGMSGTL(("SnmpAgent", "[%s:%d]Ret=%d\n", SRC_FILE_NAME, __LINE__, iRet));
    }
#endif

    iRet = netsnmp_register_scalar(netsnmp_create_handler_registration
                                   ("IrOut",
                                    handle_IrOut,
                                    IrOut_oid,
                                    OID_LENGTH(IrOut_oid),
                                    HANDLER_CAN_RWRITE));
    if (MIB_REGISTERED_OK != iRet) {
        DEBUGMSGTL(("SnmpAgent", "[%s:%d]Ret=%d\n", SRC_FILE_NAME, __LINE__, iRet));
    }

    iRet = netsnmp_register_scalar(netsnmp_create_handler_registration
                                   ("touchScreenCalibrate",
                                    handle_touchScreenCalibrate,
                                    touchScreenCalibrate_oid,
                                    OID_LENGTH(touchScreenCalibrate_oid),
                                    HANDLER_CAN_RWRITE));
    if (MIB_REGISTERED_OK != iRet) {
        DEBUGMSGTL(("SnmpAgent", "[%s:%d]Ret=%d\n", SRC_FILE_NAME, __LINE__, iRet));
    }

	iRet = netsnmp_register_scalar(
		netsnmp_create_handler_registration("HdmiCecCtrl", handle_HdmiCecCtrl, HdmiCecCtrl_oid, OID_LENGTH(HdmiCecCtrl_oid), HANDLER_CAN_RWRITE)
		);
	if (MIB_REGISTERED_OK != iRet) {
		DEBUGMSGTL(("SnmpAgent", "[%s:%d]Ret=%d\n", SRC_FILE_NAME, __LINE__, iRet));
	}

    iRet = netsnmp_register_scalar(netsnmp_create_handler_registration
                                   ("IrLevelOut",
                                    handle_IrLevelOut,
                                    IrLevelOut_oid,
                                    OID_LENGTH(IrLevelOut_oid),
                                    HANDLER_CAN_RWRITE));
    if (MIB_REGISTERED_OK != iRet) {
        DEBUGMSGTL(("SnmpAgent", "[%s:%d]Ret=%d\n", SRC_FILE_NAME, __LINE__, iRet));
    }

    iRet = netsnmp_register_scalar(netsnmp_create_handler_registration
            ("enableAudio6Ch",
            handle_enableAudio6Ch, 
            enableAudio6Ch_oid,
            OID_LENGTH(enableAudio6Ch_oid), 
            HANDLER_CAN_RWRITE));
    if(MIB_REGISTERED_OK != iRet)
    {
        DEBUGMSGTL(("SnmpAgent", "[%s:%d]Ret=%d\n", SRC_FILE_NAME, __LINE__, iRet));
    }
	
}

int
handle_cardCurrentStatus(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests)
{
	int iSnmpErrNo = SNMP_ERR_NOERROR;
	int iRet;

    UNUSED(handler);
    UNUSED(reginfo);
    UNUSED(requests);

    switch (reqinfo->mode) 
	{
	    case MODE_GET:
		{
			SharedPtr <CDBusMessage> DbusMsgCall_sp;
			DbusMsgCall_sp = CDBusMessage::createMethodCall(DBUS_SrvName_ControlCenter,
				DBUS_PATH_WebBrowser_UiSrv, DBUS_IF_ControlCenter_UiSrv,
				DBUS_METHOD_getCardCurrentStatus);
			if(DbusMsgCall_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			SharedPtr <CDBusMessage> DbusMsgReply_sp;
			DbusMsgReply_sp = CDbusConnection::Call(connectToDBus(), DbusMsgCall_sp, DBUS_CALL_DEFAULT_TIMEOUT_MS);
			if(DbusMsgReply_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			SharedPtr <CDBusParameterList> DbusParamListReceived_sp(new CDBusParameterList);
			if(DbusParamListReceived_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			(*DbusParamListReceived_sp) << (*DbusMsgReply_sp);
			if(2 > DbusParamListReceived_sp->getSize())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			iRet = (*DbusParamListReceived_sp)[0]->toInt32();
			if(ERROR_SUCCESS != iRet)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			DECLARE_CLS_STACK_BUF_STRING(strCardCurrentStatus, 512);
			strCardCurrentStatus = (*DbusParamListReceived_sp)[1]->toString();
			CByteArray2 binCardCurrentStatus;
			iRet = binCardCurrentStatus.SetSize((strCardCurrentStatus.getStringLength()+3)*3/4);
			if(ERROR_SUCCESS != iRet)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			INT_t iOutSize = binCardCurrentStatus.GetSize();
			iRet = Base64Decode((PBYTE)(LPCSTR)strCardCurrentStatus, strCardCurrentStatus.getStringLength(),
				binCardCurrentStatus.GetData(), &iOutSize);
			if(ERROR_SUCCESS != iRet)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			iRet = binCardCurrentStatus.SetSize(iOutSize);
			if(ERROR_SUCCESS != iRet)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			iRet = snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, binCardCurrentStatus.GetData(),
				binCardCurrentStatus.GetSize());
			if(0 != iRet)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			break;		
		}
	    default:
	        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_cardCurrentStatus\n",
                 reqinfo->mode);
	        return SNMP_ERR_GENERR;
    }

    return iSnmpErrNo;
}

int
handle_currentClockTicks(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests)
{
    int ret, value;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        if (DBus_getProperty(SPBus_MPlayer, "getCurClkTicks", NULL,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: getInt='%d'\n", __FUNCTION__, value));

        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value, sizeof(value));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        value = *requests->requestvb->val.integer;
        DEBUGMSGTL(("Interface", "%s: setInt='%d'\n", __FUNCTION__, value));

        if (DBus_setProperty(SPBus_MPlayer, "setCurClkTicks", NULL,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_currentClockTicks\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_mediaKey(netsnmp_mib_handler *handler,
                netsnmp_handler_registration *reginfo,
                netsnmp_agent_request_info *reqinfo,
                netsnmp_request_info *requests)
{
    int             ret;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
#if 0
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)
                                 /* XXX: a pointer to the scalar's data */
                                 ,
                                 /*
                                  * XXX: the length of the data in bytes 
                                  */ );
#endif
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        if (0 /* XXX: error? */ ) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
        break;

    case MODE_SET_COMMIT:
        if (0 /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_mediaKey\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_formatMedia(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    int ret, value;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        value = 0;
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value, sizeof(value));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        value = *requests->requestvb->val.integer;
        if (value < 0 || value > 3) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: setInt='%d'\n", __FUNCTION__, value));

        if (DBus_setProperty(SPBus_ControlCenter_UiSrv, "setFormatMedia", NULL,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_formatMedia\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_scanMedia(netsnmp_mib_handler *handler,
                 netsnmp_handler_registration *reginfo,
                 netsnmp_agent_request_info *reqinfo,
                 netsnmp_request_info *requests)
{
    int             ret;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
#if 0
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)
                                 /* XXX: a pointer to the scalar's data */
                                 ,
                                 /*
                                  * XXX: the length of the data in bytes 
                                  */ );
#endif
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        if (0 /* XXX: error? */ ) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
        break;

    case MODE_SET_COMMIT:
        if (0 /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_scanMedia\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_mediaStatus(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
	int iSnmpErrNo = SNMP_ERR_NOERROR, iRet;

    UNUSED(handler);
    UNUSED(reginfo);
    UNUSED(requests);

	if(Sw_LogDbusCmd)
	{
		LOG_BLINE("SnmpAgent: mediaStatus\n");
	}

    switch (reqinfo->mode) 
	{
	    case MODE_GET:
		{
			SharedPtr <CDBusMessage> DbusMsgCall_sp;
			DbusMsgCall_sp = CDBusMessage::createMethodCall(DBUS_SrvName_ControlCenter,
				DBUS_PATH_WebBrowser_UiSrv, DBUS_IF_ControlCenter_UiSrv,
				DBUS_METHOD_getMediaStatus);
			if(DbusMsgCall_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			SharedPtr <CDBusMessage> DbusMsgReply_sp;
			DbusMsgReply_sp = CDbusConnection::Call(connectToDBus(), DbusMsgCall_sp, DBUS_CALL_DEFAULT_TIMEOUT_MS);
			if(DbusMsgReply_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			SharedPtr <CDBusParameterList> DbusParamListReceived_sp(new CDBusParameterList);
			if(DbusParamListReceived_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			(*DbusParamListReceived_sp) << (*DbusMsgReply_sp);
			if(2 > DbusParamListReceived_sp->getSize())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			iRet = (*DbusParamListReceived_sp)[0]->toInt32();
			if(ERROR_SUCCESS != iRet)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			CString strMediaStatus = (*DbusParamListReceived_sp)[1]->toString();
			iRet = snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, 
				(LPCSTR)strMediaStatus, strMediaStatus.GetStrLength());
			if(0 != iRet)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			break;		
		}
	    default:
		{
	        snmp_log(LOG_ERR, "unknown mode (%d) in handle_mediaStatus\n", reqinfo->mode);
	        return SNMP_ERR_GENERR;
	    }
    }

	return iSnmpErrNo;
}

int
handle_rebootSystem(netsnmp_mib_handler *handler,
                    netsnmp_handler_registration *reginfo,
                    netsnmp_agent_request_info *reqinfo,
                    netsnmp_request_info *requests)
{
    int ret, value;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        value = 0;
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value, sizeof(value));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        value = *requests->requestvb->val.integer;
#if 0
        if ((value != 0) && value != 1) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }
#endif
        DEBUGMSGTL(("Interface", "%s: setInt='%d'\n", __FUNCTION__, value));

        if (DBus_setProperty(SPBus_ControlCenter_UiSrv, "setrebootSystem", NULL,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_rebootSystem\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_firmwareUpgradeAddress(netsnmp_mib_handler *handler,
                              netsnmp_handler_registration *reginfo,
                              netsnmp_agent_request_info *reqinfo,
                              netsnmp_request_info *requests)
{
    int             ret;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
#if 0
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)
                                 /* XXX: a pointer to the scalar's data */
                                 ,
                                 /*
                                  * XXX: the length of the data in bytes 
                                  */ );
#endif
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        if (0 /* XXX: error? */ ) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
        break;

    case MODE_SET_COMMIT:
        if (0 /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_firmwareUpgradeAddress\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_autoAnnounce(netsnmp_mib_handler *handler,
                    netsnmp_handler_registration *reginfo,
                    netsnmp_agent_request_info *reqinfo,
                    netsnmp_request_info *requests)
{
	int iSnmpErrNo = SNMP_ERR_NOERROR;
	int iRet;
    int             ret;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
	    case MODE_GET:
		{
			SharedPtr <CDBusMessage> DbusMsgCall_sp;
			DbusMsgCall_sp = CDBusMessage::createMethodCall(DBUS_SrvName_ControlCenter,
				DBUS_PATH_WebBrowser_UiSrv, DBUS_IF_ControlCenter_UiSrv,
				DBUS_METHOD_getAutoAnnounce);
			if(DbusMsgCall_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			SharedPtr <CDBusMessage> DbusMsgReply_sp;
			DbusMsgReply_sp = CDbusConnection::Call(connectToDBus(), DbusMsgCall_sp, DBUS_CALL_DEFAULT_TIMEOUT_MS);
			if(DbusMsgReply_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			SharedPtr <CDBusParameterList> DbusParamListReceived_sp(new CDBusParameterList);
			if(DbusParamListReceived_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			(*DbusParamListReceived_sp) << (*DbusMsgReply_sp);
			if(2 > DbusParamListReceived_sp->getSize())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			iRet = (*DbusParamListReceived_sp)[0]->toInt32();
			if(ERROR_SUCCESS != iRet)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			INT_t iAutoAnnounceIntervalSec = (*DbusParamListReceived_sp)[1]->toInt32();
			iRet = snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER, iAutoAnnounceIntervalSec);
			if(0 != iRet)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			break;		
		}

	    case MODE_SET_RESERVE1:
	        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
	        if (ret != SNMP_ERR_NOERROR) {
	            netsnmp_set_request_error(reqinfo, requests, ret);
	        }
	        break;

	    case MODE_SET_RESERVE2:
	        break;

	    case MODE_SET_FREE:
	        break;

	    case MODE_SET_ACTION:
		{
			int iAutoAnnounceIntervalSec = *(requests->requestvb->val.integer);
			SharedPtr <CDBusMessage> DbusMsgCall_sp;
			DbusMsgCall_sp = CDBusMessage::createMethodCall(DBUS_SrvName_ControlCenter,
				DBUS_PATH_WebBrowser_UiSrv, DBUS_IF_ControlCenter_UiSrv,
				DBUS_METHOD_setAutoAnnounce);
			if(DbusMsgCall_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			SharedPtr <CDBusParameterList> DbusParamListToSend_sp(new CDBusParameterList);
			if(DbusParamListToSend_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			try
			{
				(*DbusParamListToSend_sp) << iAutoAnnounceIntervalSec;
			}
			catch(std::bad_alloc & BadAllocEx)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			iRet = ((*DbusParamListToSend_sp) >> DbusMsgCall_sp);
			if(ERROR_SUCCESS != iRet)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}			
			SharedPtr <CDBusMessage> DbusMsgReply_sp;
			DbusMsgReply_sp = CDbusConnection::Call(connectToDBus(), DbusMsgCall_sp, DBUS_CALL_DEFAULT_TIMEOUT_MS);
			if(DbusMsgReply_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			SharedPtr <CDBusParameterList> DbusParamListReceived_sp(new CDBusParameterList);
			if(DbusParamListReceived_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			(*DbusParamListReceived_sp) << (*DbusMsgReply_sp);
			if(1 > DbusParamListReceived_sp->getSize())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			iRet = (*DbusParamListReceived_sp)[0]->toInt32();
			if(ERROR_SUCCESS != iRet)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			break;
		}

	    case MODE_SET_COMMIT:
	        if (0 /* XXX: error? */ ) {
				/*
				* try _really_really_ hard to never get to this point 
				*/
	            netsnmp_set_request_error(reqinfo, requests,
	                                      SNMP_ERR_COMMITFAILED);
	        }
	        break;

	    case MODE_SET_UNDO:
	        break;

	    default:
			/*
			* we should never get here, so this is a really bad error 
			*/
	        snmp_log(LOG_ERR, "unknown mode (%d) in handle_autoAnnounce\n",
	                 reqinfo->mode);
	        return SNMP_ERR_GENERR;
    }

    return iSnmpErrNo;
}

int
handle_communicationProtocol(netsnmp_mib_handler *handler,
                             netsnmp_handler_registration *reginfo,
                             netsnmp_agent_request_info *reqinfo,
                             netsnmp_request_info *requests)
{
    int             ret;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
#if 0
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)
                                 /* XXX: a pointer to the scalar's data */
                                 ,
                                 /*
                                  * XXX: the length of the data in bytes 
                                  */ );
#endif
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        if (0 /* XXX: error? */ ) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
        break;

    case MODE_SET_COMMIT:
        if (0 /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_communicationProtocol\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_configSave(netsnmp_mib_handler *handler,
                  netsnmp_handler_registration *reginfo,
                  netsnmp_agent_request_info *reqinfo,
                  netsnmp_request_info *requests)
{
    int             ret;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
#if 0
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)
                                 /* XXX: a pointer to the scalar's data */
                                 ,
                                 /*
                                  * XXX: the length of the data in bytes 
                                  */ );
#endif
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        if (0 /* XXX: error? */ ) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
        break;

    case MODE_SET_COMMIT:
        if (0 /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_configSave\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_configSaveOption(netsnmp_mib_handler *handler,
                        netsnmp_handler_registration *reginfo,
                        netsnmp_agent_request_info *reqinfo,
                        netsnmp_request_info *requests)
{
    int             ret;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
#if 0
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)
                                 /* XXX: a pointer to the scalar's data */
                                 ,
                                 /*
                                  * XXX: the length of the data in bytes 
                                  */ );
#endif
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        if (0 /* XXX: error? */ ) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
        break;

    case MODE_SET_COMMIT:
        if (0 /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_configSaveOption\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_tnetVersion(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
	int ret, value;
    UNUSED(handler);
    UNUSED(reginfo);
    UNUSED(requests);

    switch (reqinfo->mode) {
    case MODE_GET:
        if (DBus_getProperty(SPBus_ControlCenter_UiSrv, "get_tnetVersion", NULL,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: getInt='%d'\n", __FUNCTION__, value));

        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value, sizeof(value));
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_tnetVersion\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_selfTest(netsnmp_mib_handler *handler,
                netsnmp_handler_registration *reginfo,
                netsnmp_agent_request_info *reqinfo,
                netsnmp_request_info *requests)
{
    int             ret;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
#if 0
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)
                                 /* XXX: a pointer to the scalar's data */
                                 ,
                                 /*
                                  * XXX: the length of the data in bytes 
                                  */ );
#endif
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        if (0 /* XXX: error? */ ) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
        break;

    case MODE_SET_COMMIT:
        if (0 /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_selfTest\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_priTimeServer(netsnmp_mib_handler *handler,
                     netsnmp_handler_registration *reginfo,
                     netsnmp_agent_request_info *reqinfo,
                     netsnmp_request_info *requests)
{
    int ret;
    unsigned int val_len;
    const char *pValue;
    char szVaule[129];

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        if (DBus_getProperty(SPBus_SystemService_NetworkManager, "getPrimaryTimeServer", NULL,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_STRING, &pValue,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: getString='%s'\n", __FUNCTION__, pValue));

        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)pValue, strlen(pValue));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        val_len = requests->requestvb->val_len;
        if (val_len + 1 > sizeof(szVaule) || val_len < 1) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }
        pValue = (const char *)requests->requestvb->val.string;
        strncpy(szVaule, pValue, val_len);
        szVaule[val_len] = 0;
        pValue = szVaule;
        DEBUGMSGTL(("Interface", "%s: setString='%s'\n", __FUNCTION__, pValue));

        if (DBus_setProperty(SPBus_SystemService_NetworkManager, "setPrimaryTimeServer", NULL,
                              DBUS_TYPE_STRING, &pValue,
                              DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_priTimeServer\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_secTimeServer(netsnmp_mib_handler *handler,
                     netsnmp_handler_registration *reginfo,
                     netsnmp_agent_request_info *reqinfo,
                     netsnmp_request_info *requests)
{
    int ret;
    unsigned int val_len;
    const char *pValue;
    char szVaule[129];

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        if (DBus_getProperty(SPBus_SystemService_NetworkManager, "getSecondaryTimeServer", NULL,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_STRING, &pValue,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: getString='%s'\n", __FUNCTION__, pValue));

        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)pValue, strlen(pValue));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        val_len = requests->requestvb->val_len;
        if (val_len + 1 > sizeof(szVaule) || val_len < 1) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }
        pValue = (const char *)requests->requestvb->val.string;
        strncpy(szVaule, pValue, val_len);
        szVaule[val_len] = 0;
        pValue = szVaule;
        DEBUGMSGTL(("Interface", "%s: setString='%s'\n", __FUNCTION__, pValue));

        if (DBus_setProperty(SPBus_SystemService_NetworkManager, "setSecondaryTimeServer", NULL,
                              DBUS_TYPE_STRING, &pValue,
                              DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_secTimeServer\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_timeZone(netsnmp_mib_handler *handler,
                netsnmp_handler_registration *reginfo,
                netsnmp_agent_request_info *reqinfo,
                netsnmp_request_info *requests)
{
    int ret, value;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
		if (DBus_getProperty(SPBus_MPlayer, "getTimeZoneSetting", NULL,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: getInt='%d'\n", __FUNCTION__, value));

        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value, sizeof(value));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        value = *requests->requestvb->val.integer;
        DEBUGMSGTL(("Interface", "%s: setInt='%d'\n", __FUNCTION__, value));
        if (DBus_setProperty(SPBus_MPlayer, "setTimeZoneSetting", NULL,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_timeZone\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_pushConfig(netsnmp_mib_handler *handler,
                  netsnmp_handler_registration *reginfo,
                  netsnmp_agent_request_info *reqinfo,
                  netsnmp_request_info *requests)
{
    int ret;
    char *pValue;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)"", 0);
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        if (requests->requestvb->val_len > 512) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }

        pValue = netsnmp_strdup_and_null(requests->requestvb->val.string,
                                         requests->requestvb->val_len);

        DEBUGMSGTL(("Interface", "%s: setString='%s'\n", __FUNCTION__, pValue));

        if (DBus_setProperty(SPBus_ControlCenter_UiSrv, "setPushConfig", NULL,
                              DBUS_TYPE_STRING, &pValue,
                              DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        }
        SNMP_FREE(pValue);
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_pushConfig\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_pullConfig(netsnmp_mib_handler *handler,
                  netsnmp_handler_registration *reginfo,
                  netsnmp_agent_request_info *reqinfo,
                  netsnmp_request_info *requests)
{
    int ret;
    char *pValue;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)"", 0);
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        if (requests->requestvb->val_len > 512) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }

        pValue = netsnmp_strdup_and_null(requests->requestvb->val.string,
                                         requests->requestvb->val_len);

        DEBUGMSGTL(("Interface", "%s: setString='%s'\n", __FUNCTION__, pValue));

        if (DBus_setProperty(SPBus_ControlCenter_UiSrv, "setPullConfig", NULL,
                              DBUS_TYPE_STRING, &pValue,
                              DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        }
        SNMP_FREE(pValue);
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_pullConfig\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_restorePreviousConfiguration(netsnmp_mib_handler *handler,
                                    netsnmp_handler_registration *reginfo,
                                    netsnmp_agent_request_info *reqinfo,
                                    netsnmp_request_info *requests)
{
    int             ret;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
#if 0
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)
                                 /* XXX: a pointer to the scalar's data */
                                 ,
                                 /*
                                  * XXX: the length of the data in bytes 
                                  */ );
#endif
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        if (0 /* XXX: error? */ ) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
        break;

    case MODE_SET_COMMIT:
        if (0 /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_restorePreviousConfiguration\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_transferLog(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    int ret;
	char *pValue;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)"", 0);
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

	case MODE_SET_ACTION:
        if (requests->requestvb->val_len > 512) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }

        pValue = netsnmp_strdup_and_null(requests->requestvb->val.string,
                                         requests->requestvb->val_len);

        DEBUGMSGTL(("Interface", "%s: setString='%s'\n", __FUNCTION__, pValue));

        if (DBus_setProperty(SPBus_ControlCenter_UiSrv, "setTransferLog", NULL,
                             DBUS_TYPE_STRING, &pValue,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        }
        SNMP_FREE(pValue);
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_transferLog\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_softwareUpgradeAddress(netsnmp_mib_handler *handler,
                              netsnmp_handler_registration *reginfo,
                              netsnmp_agent_request_info *reqinfo,
                              netsnmp_request_info *requests)
{
    int             ret;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
#if 0
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)
                                 /* XXX: a pointer to the scalar's data */
                                 ,
                                 /*
                                  * XXX: the length of the data in bytes 
                                  */ );
#endif
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        if (0 /* XXX: error? */ ) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
        break;

    case MODE_SET_COMMIT:
        if (0 /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_softwareUpgradeAddress\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_userOSDAddress(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests)
{
    int ret;
    char *pValue;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
		snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
								 (u_char *)"", 0);
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        if (requests->requestvb->val_len > 512) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }

        pValue = netsnmp_strdup_and_null(requests->requestvb->val.string,
                                         requests->requestvb->val_len);

        DEBUGMSGTL(("Interface", "%s: setString='%s'\n", __FUNCTION__, pValue));

        if (DBus_setProperty(SPBus_ControlCenter_UiSrv, "setUserOSDAddress", NULL,
                              DBUS_TYPE_STRING, &pValue,
                              DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        }
        SNMP_FREE(pValue);
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_userOSDAddress\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_deviceKey(netsnmp_mib_handler *handler,
                 netsnmp_handler_registration *reginfo,
                 netsnmp_agent_request_info *reqinfo,
                 netsnmp_request_info *requests)
{
    int ret;
	char *pValue;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
		snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
								 (u_char *)"", 0);
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
		if (requests->requestvb->val_len > 32) {
			netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
			break;
		}
		pValue = netsnmp_strdup_and_null(requests->requestvb->val.string,
										 requests->requestvb->val_len);

		DEBUGMSGTL(("Interface", "%s: setString='%s'\n", __FUNCTION__, pValue));

		if (DBus_setProperty(SPBus_ControlCenter_UiSrv, "setDeviceKey", NULL,
							 DBUS_TYPE_STRING, &pValue,
							 DBUS_TYPE_INVALID) != 0) {
			netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
		}
		SNMP_FREE(pValue);
		break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_deviceKey\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_enabledFeatures(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info *reqinfo,
                       netsnmp_request_info *requests)
{
	int ret, value;
    UNUSED(handler);
    UNUSED(reginfo);
    UNUSED(requests);

    switch (reqinfo->mode) {
    case MODE_GET:
        if (DBus_getProperty(SPBus_ControlCenter_UiSrv, "getEnabledFeatures", NULL,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: getInt='%d'\n", __FUNCTION__, value));

        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value, sizeof(value));
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_enabledFeatures\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_maintainLog(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    int ret, value;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        value = 0;
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value, sizeof(value));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        value = *requests->requestvb->val.integer;
        DEBUGMSGTL(("Interface", "%s: setInt='%d'\n", __FUNCTION__, value));

        if (DBus_setProperty(SPBus_ControlCenter_UiSrv, "setMaintainLog", NULL,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_maintainLog\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_irControl(netsnmp_mib_handler *handler,
                 netsnmp_handler_registration *reginfo,
                 netsnmp_agent_request_info *reqinfo,
                 netsnmp_request_info *requests)
{
    int ret, value;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        if (DBus_getProperty(SPBus_SystemService_IrInputCtrl, "getInputEnabled", NULL,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: getInt='%d'\n", __FUNCTION__, value));

        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value, sizeof(value));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        value = *requests->requestvb->val.integer;
        if (value < 0 && value > 2) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: setInt='%d'\n", __FUNCTION__, value));

        if (DBus_setProperty(SPBus_SystemService_IrInputCtrl, "EnableDisableInput", NULL,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_irControl\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_trapEnable(netsnmp_mib_handler *handler,
                  netsnmp_handler_registration *reginfo,
                  netsnmp_agent_request_info *reqinfo,
                  netsnmp_request_info *requests)
{
    int ret, value;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        if (DBus_getProperty(SPBus_ControlCenter_UiSrv, "getTrapEnable", NULL,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: getInt='%d'\n", __FUNCTION__, value));

        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value, sizeof(value));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        value = *requests->requestvb->val.integer;
        if (value != 0 && value != 1) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: setInt='%d'\n", __FUNCTION__, value));

        if (DBus_setProperty(SPBus_ControlCenter_UiSrv, "setTrapEnable", NULL,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_trapEnable\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_trapReceiverAddress(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests)
{
    int ret;
    char *pValue;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        if (DBus_getProperty(SPBus_SystemService_NetworkManager, "getTrapReceiverAddress", NULL,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_STRING, &pValue,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: getString='%s'\n", __FUNCTION__, pValue));

        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)pValue, strlen(pValue));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        if (requests->requestvb->val_len > 64) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }

        pValue = netsnmp_strdup_and_null(requests->requestvb->val.string,
                                         requests->requestvb->val_len);

        DEBUGMSGTL(("Interface", "%s: setString='%s'\n", __FUNCTION__, pValue));

        if (DBus_setProperty(SPBus_SystemService_NetworkManager, "setTrapReceiverAddress", NULL,
                             DBUS_TYPE_STRING, &pValue,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        }
        SNMP_FREE(pValue);
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_trapReceiverAddress\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_webAdminPassword(netsnmp_mib_handler *handler,
                        netsnmp_handler_registration *reginfo,
                        netsnmp_agent_request_info *reqinfo,
                        netsnmp_request_info *requests)
{
    int             ret;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
#if 0
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)
                                 /* XXX: a pointer to the scalar's data */
                                 ,
                                 /*
                                  * XXX: the length of the data in bytes 
                                  */ );
#endif
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        if (0 /* XXX: error? */ ) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
        break;

    case MODE_SET_COMMIT:
        if (0 /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_webAdminPassword\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_snmpV3Only(netsnmp_mib_handler *handler,
                  netsnmp_handler_registration *reginfo,
                  netsnmp_agent_request_info *reqinfo,
                  netsnmp_request_info *requests)
{
    int ret, value;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        if (DBus_getProperty(SPBus_SystemService_NetworkManager, "getSnmpdV3Only", NULL,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: getInt='%d'\n", __FUNCTION__, value));

        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value, sizeof(value));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        value = *requests->requestvb->val.integer;
        if (value != 0 && value != 1) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: setInt='%d'\n", __FUNCTION__, value));

        if (DBus_setProperty(SPBus_SystemService_NetworkManager, "setSnmpdV3Only", NULL,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_snmpV3Only\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_snmpCommunity(netsnmp_mib_handler *handler,
                     netsnmp_handler_registration *reginfo,
                     netsnmp_agent_request_info *reqinfo,
                     netsnmp_request_info *requests)
{
    int ret;
	char *pValue;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
	case MODE_GET:
        if (DBus_getProperty(SPBus_SystemService_NetworkManager, "getSnmpCommunity", NULL,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_STRING, &pValue,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: getString='%s'\n", __FUNCTION__, pValue));

		snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)pValue, strlen(pValue));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

	case MODE_SET_ACTION:
        if (requests->requestvb->val_len > 32) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }
        pValue = netsnmp_strdup_and_null(requests->requestvb->val.string,
                                         requests->requestvb->val_len);
        DEBUGMSGTL(("Interface", "%s: setString='%s'\n", __FUNCTION__, pValue));

        if (DBus_setProperty(SPBus_SystemService_NetworkManager, "setSnmpCommunity", NULL,
                             DBUS_TYPE_STRING, &pValue,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        }
        SNMP_FREE(pValue);
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_snmpCommunity\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_multipleUpgradeAddress(netsnmp_mib_handler *handler,
                              netsnmp_handler_registration *reginfo,
                              netsnmp_agent_request_info *reqinfo,
                              netsnmp_request_info *requests)
{
    int ret;
    char *pValue;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)"", 0);
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        if (requests->requestvb->val_len > 256) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }

        pValue = netsnmp_strdup_and_null(requests->requestvb->val.string,
                                         requests->requestvb->val_len);

        DEBUGMSGTL(("Interface", "%s: setString='%s'\n", __FUNCTION__, pValue));

        if (DBus_setProperty(SPBus_ControlCenter_UiSrv, "setUpgradeAddress", NULL,
                              DBUS_TYPE_STRING, &pValue,
                              DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        }
        SNMP_FREE(pValue);
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_multipleUpgradeAddress\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_gpioInterruptSource(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests)
{
    int ret, vaule;
    UNUSED(handler);
    UNUSED(reginfo);
    UNUSED(requests);

    switch (reqinfo->mode) {
    case MODE_GET:
        if (DBus_getProperty(SPBus_GpioBtnInput, "getGpioInterruptSource", NULL,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_INT32, &vaule,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: getInt='%d'\n", __FUNCTION__, vaule));

        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&vaule, sizeof(vaule));
        break;

    default:
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_gpioInterruptSource\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_configDateTime(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests)
{
    int ret, value;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        if (DBus_getProperty(SPBus_MPlayer, "getConfigDateTime", NULL,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: getInt='%d'\n", __FUNCTION__, value));

        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value, sizeof(value));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        value = *requests->requestvb->val.integer;
        DEBUGMSGTL(("Interface", "%s: setInt='%d'\n", __FUNCTION__, value));

        if (DBus_setProperty(SPBus_MPlayer, "setConfigDateTime", NULL,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_configDateTime\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_loggingEnable(netsnmp_mib_handler *handler,
                     netsnmp_handler_registration *reginfo,
                     netsnmp_agent_request_info *reqinfo,
                     netsnmp_request_info *requests)
{
    int ret, value;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        if (DBus_getProperty(SPBus_SystemService_NetworkManager, "getLoggingEnable", NULL,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;           
        }   
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: getInt='%d'\n", __FUNCTION__, value));
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value, sizeof(value));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        value = *requests->requestvb->val.integer;
        DEBUGMSGTL(("Interface", "%s: setInt='%d'\n", __FUNCTION__, value));

        if (DBus_setProperty(SPBus_SystemService_NetworkManager, "setLoggingEnable", NULL,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
	break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
		/*
		* we should never get here, so this is a really bad error 
		*/
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_loggingEnable\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_xappVersion(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
	int ret;
	char *pValue;
    UNUSED(handler);
    UNUSED(reginfo);
    UNUSED(requests);

    switch (reqinfo->mode) {
    case MODE_GET:
        if (DBus_getProperty(SPBus_ControlCenter_UiSrv, "getXappVersion", NULL,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_STRING, &pValue,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: getString='%s'\n", __FUNCTION__, pValue));

		snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)pValue, strlen(pValue));
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_xappVersion\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_systemUpgradeAddress(netsnmp_mib_handler *handler,
                            netsnmp_handler_registration *reginfo,
                            netsnmp_agent_request_info *reqinfo,
                            netsnmp_request_info *requests)
{
    int ret;
    char *pValue = NULL;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)"", 0);
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        if (requests->requestvb->val_len > 256) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }

        pValue = netsnmp_strdup_and_null(requests->requestvb->val.string,
                                         requests->requestvb->val_len);

        DEBUGMSGTL(("Interface", "%s: setString='%s'\n", __FUNCTION__, pValue));

        if (DBus_setProperty(SPBus_ControlCenter_UiSrv, "setSystemUpgradeAddress", NULL,
                              DBUS_TYPE_STRING, &pValue,
                              DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        }
        SNMP_FREE(pValue);
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_systemUpgradeAddress\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_autoReboot(netsnmp_mib_handler *handler,
                  netsnmp_handler_registration *reginfo,
                  netsnmp_agent_request_info *reqinfo,
                  netsnmp_request_info *requests)
{
    int ret, value;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        if (DBus_getProperty(SPBus_ControlCenter_UiSrv, "getAutoReboot", NULL,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: getInt='%d'\n", __FUNCTION__, value));

        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value, sizeof(value));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        value = *requests->requestvb->val.integer;
        if ((value != 0) && value != 1) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: setInt='%d'\n", __FUNCTION__, value));

        if (DBus_setProperty(SPBus_ControlCenter_UiSrv, "setAutoReboot", NULL,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_autoReboot\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_autoRebootInterval(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    int ret, value;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        if (DBus_getProperty(SPBus_ControlCenter_UiSrv, "getAutoRebootInterval", NULL,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: getInt='%d'\n", __FUNCTION__, value));

        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value, sizeof(value));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        value = *requests->requestvb->val.integer;
#if 0
        if (value < 180) {
            // Anything less than 180 seconds is too low of a value
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }
#endif
        DEBUGMSGTL(("Interface", "%s: setInt='%d'\n", __FUNCTION__, value));

        if (DBus_setProperty(SPBus_ControlCenter_UiSrv, "setAutoRebootInterval", NULL,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_autoRebootInterval\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_audioOutputMode(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests)

{
	int iSnmpErrNo = SNMP_ERR_NOERROR;
	int iRet;
    int             ret;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
	    case MODE_GET:
		{
			SharedPtr <CDBusMessage> DbusMsgCall_sp;
			DbusMsgCall_sp = CDBusMessage::createMethodCall(DBUS_SrvName_ControlCenter,
				DBUS_PATH_WebBrowser_UiSrv, DBUS_IF_ControlCenter_UiSrv,
				DBUS_METHOD_getAudioOutputMode);
			if(DbusMsgCall_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			SharedPtr <CDBusMessage> DbusMsgReply_sp;
			DbusMsgReply_sp = CDbusConnection::Call(connectToDBus(), DbusMsgCall_sp, DBUS_CALL_DEFAULT_TIMEOUT_MS);
			if(DbusMsgReply_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			SharedPtr <CDBusParameterList> DbusParamListReceived_sp(new CDBusParameterList);
			if(DbusParamListReceived_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			(*DbusParamListReceived_sp) << (*DbusMsgReply_sp);
			if(2 > DbusParamListReceived_sp->getSize())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			iRet = (*DbusParamListReceived_sp)[0]->toInt32();
			if(ERROR_SUCCESS != iRet)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			INT_t iAudioOutputMode = (*DbusParamListReceived_sp)[1]->toInt32();
			iRet = snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER, iAudioOutputMode);
			if(0 != iRet)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			break;		
		}

	    case MODE_SET_RESERVE1:
	        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
	        if (ret != SNMP_ERR_NOERROR) {
	            netsnmp_set_request_error(reqinfo, requests, ret);
	        }
	        break;

	    case MODE_SET_RESERVE2:
	        break;

	    case MODE_SET_FREE:
	        break;

	    case MODE_SET_ACTION:
		{
			int iAudioOutputMode = *(requests->requestvb->val.integer);
			SharedPtr <CDBusMessage> DbusMsgCall_sp;
			DbusMsgCall_sp = CDBusMessage::createMethodCall(DBUS_SrvName_ControlCenter,
				DBUS_PATH_WebBrowser_UiSrv, DBUS_IF_ControlCenter_UiSrv,
				DBUS_METHOD_setAudioOutputMode);
			if(DbusMsgCall_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			SharedPtr <CDBusParameterList> DbusParamListToSend_sp(new CDBusParameterList);
			if(DbusParamListToSend_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			try
			{
				(*DbusParamListToSend_sp) << iAudioOutputMode;
			}
			catch(std::bad_alloc & BadAllocEx)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			iRet = ((*DbusParamListToSend_sp) >> DbusMsgCall_sp);
			if(ERROR_SUCCESS != iRet)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}			
			SharedPtr <CDBusMessage> DbusMsgReply_sp;
			DbusMsgReply_sp = CDbusConnection::Call(connectToDBus(), DbusMsgCall_sp, DBUS_CALL_DEFAULT_TIMEOUT_MS);
			if(DbusMsgReply_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			SharedPtr <CDBusParameterList> DbusParamListReceived_sp(new CDBusParameterList);
			if(DbusParamListReceived_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			(*DbusParamListReceived_sp) << (*DbusMsgReply_sp);
			if(1 > DbusParamListReceived_sp->getSize())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			iRet = (*DbusParamListReceived_sp)[0]->toInt32();
			if(ERROR_SUCCESS != iRet)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			break;
		}

	    case MODE_SET_COMMIT:
	        if (0 /* XXX: error? */ ) {
			/*
			* try _really_really_ hard to never get to this point 
			*/
	            netsnmp_set_request_error(reqinfo, requests,
	                                      SNMP_ERR_COMMITFAILED);
	        }
	        break;

	    case MODE_SET_UNDO:
	        break;

	    default:
			/*
			* we should never get here, so this is a really bad error 
			*/
	        snmp_log(LOG_ERR, "unknown mode (%d) in handle_j24SelectInput\n",
	                 reqinfo->mode);
	        return SNMP_ERR_GENERR;
    }

    return iSnmpErrNo;
}


int
handle_dispOsdResolutionId(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests)
{
    int ret, value;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        if (DBus_getProperty(SPBus_WebBrowser_DataCommSrv, "getDispOsdResolutionId", NULL,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: getInt='%d'\n", __FUNCTION__, value));

        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value, sizeof(value));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        value = *requests->requestvb->val.integer;
        DEBUGMSGTL(("Interface", "%s: setInt='%d'\n", __FUNCTION__, value));

        if (DBus_setProperty(SPBus_WebBrowser_DataCommSrv, "setDispOsdResolutionId", NULL,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dispOsdResolutionId\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_cpuSerialNo(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    int ret;
    const char *pValue;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        if (DBus_getProperty(SPBus_MPlayer, "getCpuSerialNo", NULL,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_STRING, &pValue,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: getString='%s'\n", __FUNCTION__, pValue));

        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)pValue, strlen(pValue));
        break;

    default:
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_cpuSerialNo\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

#if 1 //add by bert 2016/08/27
int
handle_hardwareCapability(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    int ret, value;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        if (DBus_getProperty(SPBus_MPlayer, "gethardwareCapability", NULL,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {             
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: getInt='%d'\n", __FUNCTION__, value));

        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value, sizeof(value));
        break;

    default:
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_hardwareCapability\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif


int
handle_IrOut(netsnmp_mib_handler *handler,
             netsnmp_handler_registration *reginfo,
             netsnmp_agent_request_info *reqinfo,
             netsnmp_request_info *requests)
{
    int ret, iIRCode;
	char *pValue, *pos;

	UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
	case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)"", 0);
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

	case MODE_SET_ACTION:
		if (requests->requestvb->val_len > 4) {
			netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
			break;
		}
        pValue = netsnmp_strdup_and_null(requests->requestvb->val.string,
                                         requests->requestvb->val_len);
        DEBUGMSGTL(("Interface", "%s: setString='%s'\n", __FUNCTION__, pValue));

        iIRCode = strtol(pValue, &pos, 16);
		if (((pos - pValue) != 4)) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
			SNMP_FREE(pValue);
            break;
        }
		SNMP_FREE(pValue);

        ret = DBus_setProperty(SPBus_SystemService_IrInputCtrl, "SendIrOut", NULL,
                               DBUS_TYPE_INT32, &iIRCode, DBUS_TYPE_INVALID);
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dispOsdResolutionId\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_touchScreenCalibrate(netsnmp_mib_handler *handler,
                            netsnmp_handler_registration *reginfo,
                            netsnmp_agent_request_info *reqinfo,
                            netsnmp_request_info *requests)
{
    int ret, value;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
	case MODE_GET:
		value = 0;
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value, sizeof(value));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        value = *requests->requestvb->val.integer;
        DEBUGMSGTL(("Interface", "%s: setInt='%d'\n", __FUNCTION__, value));

        if (DBus_setProperty(SPBus_ControlCenter_UiSrv, "SetTouchScreenCalibrateAsync", NULL,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_touchScreenCalibrate\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
	handle_HdmiCecCtrl(netsnmp_mib_handler *handler,
	netsnmp_handler_registration *reginfo,
	netsnmp_agent_request_info *reqinfo,
	netsnmp_request_info *requests)
{
	int ret, value;

	UNUSED(handler);
	UNUSED(reginfo);

	switch (reqinfo->mode) {
	case MODE_GET:
		value = 0;
		snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
			(u_char *)&value, sizeof(value));
		break;

	case MODE_SET_RESERVE1:
		ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
		if (ret != SNMP_ERR_NOERROR) {
			netsnmp_set_request_error(reqinfo, requests, ret);
		}
		break;

	case MODE_SET_RESERVE2:
		break;

	case MODE_SET_FREE:
		break;

	case MODE_SET_ACTION:
		value = *requests->requestvb->val.integer;
		DEBUGMSGTL(("Interface", "%s: setInt='%d'\n", __FUNCTION__, value));

		if (DBus_setProperty(SPBus_MPlayer, "setHdmiCecCtrl", NULL,
			DBUS_TYPE_INT32, &value,
			DBUS_TYPE_INVALID) != 0) {
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
				break;
		}
		break;

	case MODE_SET_COMMIT:
		break;

	case MODE_SET_UNDO:
		break;

	default:
		snmp_log(LOG_ERR,
			"unknown mode (%d) in handle_HdmiCecCtrl\n",
			reqinfo->mode);
		return SNMP_ERR_GENERR;
	}

	return SNMP_ERR_NOERROR;
}

int
handle_IrLevelOut(netsnmp_mib_handler *handler,
             netsnmp_handler_registration *reginfo,
             netsnmp_agent_request_info *reqinfo,
             netsnmp_request_info *requests)
{
    int ret;
    char *pValue;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
	case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)"", 0);
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        if (requests->requestvb->val_len > 2048) {
			netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
			break;
	}
        pValue = netsnmp_strdup_and_null(requests->requestvb->val.string,
                                         requests->requestvb->val_len);
        DEBUGMSGTL(("Interface", "%s: setString='%s'\n", __FUNCTION__, pValue));

        ret = DBus_setProperty(SPBus_SystemService_IrInputCtrl, "SendIrLevelOut", NULL,
                               DBUS_TYPE_STRING, &pValue, DBUS_TYPE_INVALID);
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        }
        SNMP_FREE(pValue);
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_IrLevelOut\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_enableAudio6Ch(netsnmp_mib_handler *handler,
	netsnmp_handler_registration *reginfo,
	netsnmp_agent_request_info *reqinfo,
	netsnmp_request_info *requests)
{
	int ret, value;
	UNUSED(handler);
	UNUSED(reginfo);

	switch (reqinfo->mode) {
	case MODE_GET:
            if (DBus_getProperty(SPBus_MPlayer, "getEnableAudio6Ch", NULL,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) 
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
                break;
            }

            if (ret != 0) 
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
                break;
            }

            DEBUGMSGTL(("Interface", "%s: getInt='%d'\n", __FUNCTION__, value));

            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value, sizeof(value));
            break;

	case MODE_SET_RESERVE1:
		ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
		if (ret != SNMP_ERR_NOERROR) {
			netsnmp_set_request_error(reqinfo, requests, ret);
		}
		break;

	case MODE_SET_RESERVE2:
		break;

	case MODE_SET_FREE:
		break;

	case MODE_SET_ACTION:
		value = *requests->requestvb->val.integer;
		DEBUGMSGTL(("Interface", "%s: setInt='%d'\n", __FUNCTION__, value));
              if (value != 0 && value != 1)
              {
                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
                    break;
              }
              
		if (DBus_setProperty(SPBus_MPlayer, "setEnableAudio6Ch", NULL,
			DBUS_TYPE_INT32, &value,
			DBUS_TYPE_INVALID) != 0) {
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
				break;
		}
		break;

	case MODE_SET_COMMIT:
		break;

	case MODE_SET_UNDO:
		break;

	default:
		snmp_log(LOG_ERR,
			"unknown mode (%d) in handle_enableAudio6Ch\n",
			reqinfo->mode);
		return SNMP_ERR_GENERR;
	}

	return SNMP_ERR_NOERROR;
}



