/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf 17337 2009-01-01 14:28:29Z magfr $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include <ctype.h>
#include "subagent.h"
#include "media.h"
#include <ErrPrintHelper.h>
#include <WebBrowserAppDef.h>
#include <DBusMessage.h>
#include <DbusConnection.h>

#ifdef	SRC_FILE_NAME
#undef	SRC_FILE_NAME
#endif	//SRC_FILE_NAME
#define	SRC_FILE_NAME				"media.cpp"

static MediaConfig config;
static MediaConfig *pSetting;

const char *pszFileType[] = {
    "Unknown", "Video", "Audio", "Picture", "Playlist", "Html", "VideoProfile", "HTTP", "UDP", "RTP", NULL
};

const char *FileTypeString(FileType type)
{
    return pszFileType[type];
}

const char *FileTypeIndexCurrent()
{
    if (config.fileTypeIndex < FileType_Unknown)
        config.fileTypeIndex = FileType_Unknown;
    else if (config.fileTypeIndex > FileType_Invalid)
        config.fileTypeIndex = FileType_Invalid;

    return pszFileType[config.fileTypeIndex];
}

/** Initializes the media module */
void
init_media(MediaConfig *setting)
{
	int iRet;
    const oid       image1SourceAddress_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 4, 1 };
    const oid       image2SourceAddress_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 4, 2 };
    const oid       image3SourceAddress_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 4, 3 };
    const oid       activeMedia_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 4, 4 };
    const oid       fileTypeIndex_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 4, 5 };
    const oid       renameMediaFile_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 4, 7 };
    const oid       deleteMediaFile_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 4, 8 };
    const oid       freeSpace_oid[] = { 1, 3, 6, 1, 4, 1, 38010, 3, 4, 9 };
    const oid       storeVideoFile_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 4, 10 };
    const oid       storeAudioFile_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 4, 11 };
    const oid       storeImageFile_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 4, 12 };
    const oid       targetPlaylistFile_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 4, 13 };
    const oid       storePlaylistFile_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 4, 14 };
    const oid       transferControl_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 4, 15 };
    const oid       storeBrowserFile_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 4, 16 };
    const oid       ftpPut_oid[] = { 1, 3, 6, 1, 4, 1, 38010, 3, 4, 17 };

    DEBUGMSGTL(("media", "Initializing\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("image1SourceAddress",
                             handle_image1SourceAddress,
                             image1SourceAddress_oid,
                             OID_LENGTH(image1SourceAddress_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("image2SourceAddress",
                             handle_image2SourceAddress,
                             image2SourceAddress_oid,
                             OID_LENGTH(image2SourceAddress_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("image3SourceAddress",
                             handle_image3SourceAddress,
                             image3SourceAddress_oid,
                             OID_LENGTH(image3SourceAddress_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("activeMedia", handle_activeMedia,
                             activeMedia_oid, OID_LENGTH(activeMedia_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("fileTypeIndex", handle_fileTypeIndex,
                             fileTypeIndex_oid,
                             OID_LENGTH(fileTypeIndex_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("renameMediaFile", handle_renameMediaFile,
                             renameMediaFile_oid,
                             OID_LENGTH(renameMediaFile_oid),
                             HANDLER_CAN_RWRITE));
    iRet = netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("deleteMediaFile", handle_deleteMediaFile,
                             deleteMediaFile_oid,
                             OID_LENGTH(deleteMediaFile_oid),
                             HANDLER_CAN_RWRITE));
	if(MIB_REGISTERED_OK != iRet)
	{
		DEBUGMSGTL(("SnmpAgent", "[%s:%d]Ret=%d\n", SRC_FILE_NAME, __LINE__, iRet));
	}
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("freeSpace", handle_freeSpace, freeSpace_oid,
                             OID_LENGTH(freeSpace_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("storeVideoFile", handle_storeVideoFile,
                             storeVideoFile_oid,
                             OID_LENGTH(storeVideoFile_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("storeAudioFile", handle_storeAudioFile,
                             storeAudioFile_oid,
                             OID_LENGTH(storeAudioFile_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("storeImageFile", handle_storeImageFile,
                             storeImageFile_oid,
                             OID_LENGTH(storeImageFile_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("targetPlaylistFile",
                             handle_targetPlaylistFile,
                             targetPlaylistFile_oid,
                             OID_LENGTH(targetPlaylistFile_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("storePlaylistFile", handle_storePlaylistFile,
                             storePlaylistFile_oid,
                             OID_LENGTH(storePlaylistFile_oid),
                             HANDLER_CAN_RWRITE));
    iRet = netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("transferControl", handle_transferControl,
                             transferControl_oid,
                             OID_LENGTH(transferControl_oid),
                             HANDLER_CAN_RWRITE));
	if(MIB_REGISTERED_OK != iRet)
	{
		DEBUGMSGTL(("SnmpAgent", "[%s:%d]Ret=%d\n", SRC_FILE_NAME, __LINE__, iRet));
	}
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("storeBrowserFile", handle_storeBrowserFile,
                             storeBrowserFile_oid,
                             OID_LENGTH(storeBrowserFile_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("ftpPut", handle_ftpPut, ftpPut_oid,
                             OID_LENGTH(ftpPut_oid), HANDLER_CAN_RWRITE));
    pSetting = setting;
    memcpy(&config, setting, sizeof(config));
    config.fileTypeIndex = FileType_Video;
}

int
handle_image1SourceAddress(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests)
{
    int ret, val_len;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *) config.image1SourceAddress,
                                 strlen(config.image1SourceAddress));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        val_len = requests->requestvb->val_len;
        if (val_len > IMAGE_SOURCE_LEN) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGLENGTH);
            return SNMP_ERR_GENERR;
        }
        memcpy(config.image1SourceAddress, requests->requestvb->val.string, val_len);
        config.image1SourceAddress[val_len] = 0;
        break;

    case MODE_SET_COMMIT:
        if (0) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_image1SourceAddress\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_image2SourceAddress(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests)
{
    int ret, val_len;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *) config.image2SourceAddress,
                                 strlen(config.image2SourceAddress));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        val_len = requests->requestvb->val_len;
        if (val_len > IMAGE_SOURCE_LEN) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGLENGTH);
            return SNMP_ERR_GENERR;
        }
        memcpy(config.image2SourceAddress, requests->requestvb->val.string, val_len);
        config.image2SourceAddress[val_len] = 0;
        break;

    case MODE_SET_COMMIT:
        if (0) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_image1SourceAddress\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_image3SourceAddress(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests)
{
    int ret, val_len;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *) config.image3SourceAddress,
                                 strlen(config.image3SourceAddress));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        val_len = requests->requestvb->val_len;
        if (val_len > IMAGE_SOURCE_LEN) {
            netsnmp_set_request_error (reqinfo, requests, SNMP_ERR_WRONGLENGTH);
            return SNMP_ERR_GENERR;
        }
        memcpy(config.image3SourceAddress, requests->requestvb->val.string, val_len);
        config.image3SourceAddress[val_len] = 0;
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_image1SourceAddress\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_activeMedia(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    const char *pActiveMediaDesc, *pActiveMediaDirNanme, *pDevType;
    int ret, iDevType;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        if (DBus_getProperty(SPBus_WebBrowser_DataCommSrv, "getActiveMedia", NULL,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_STRING, &pActiveMediaDesc,
                             DBUS_TYPE_STRING, &pActiveMediaDirNanme,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }

        if (!strcmp(pActiveMediaDesc, "Flash"))
            iDevType = 0;
        else if (!strcmp(pActiveMediaDesc, "Usb"))
            iDevType = 1;
        else if (!strcmp(pActiveMediaDesc, "SdCard"))
            iDevType = 2;
        else if (!strcmp(pActiveMediaDesc, "HDD"))
            iDevType = 3;
        else if (!strcmp(pActiveMediaDesc, "RAM"))
            iDevType = 4;
        else if (!strcmp(pActiveMediaDesc, "Tuner"))
            iDevType = 5;
        else
            iDevType = -1;

        DEBUGMSGTL(("Interface", "%s: getString='%s' iDevType='%d'\n",
                    __FUNCTION__, pActiveMediaDesc, iDevType));

        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&iDevType, sizeof(iDevType));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        iDevType = (ActiveMedia_TYPE) *requests->requestvb->val.integer + 1;
        if (iDevType >= AMedia_TYPE_Invalid || iDevType <= AMedia_TYPE_Unknown) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            return SNMP_ERR_GENERR;
        }
        pDevType = stringActieMediaType((ActiveMedia_TYPE)iDevType);

        DEBUGMSGTL(("Interface", "%s: setInt='%d' pDevType='%s'\n", __FUNCTION__, iDevType, pDevType));

        if (DBus_setProperty(SPBus_WebBrowser_DataCommSrv, "setActiveMedia", NULL,
                              DBUS_TYPE_STRING, &pDevType,
                              DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_activeMedia\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

extern int fileListingTable_if_ctx_cache_set_expired(void);

int
handle_fileTypeIndex(netsnmp_mib_handler *handler,
                     netsnmp_handler_registration *reginfo,
                     netsnmp_agent_request_info *reqinfo,
                     netsnmp_request_info *requests)
{
    int ret, temp;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        temp = config.fileTypeIndex - 1;
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *) &temp,
                                 sizeof(temp));
        DEBUGMSGTL(("Interface", "%s: fileTypeIndex='%s'\n", __FUNCTION__, FileTypeIndexCurrent()));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        temp = *requests->requestvb->val.integer + 1;
        if (temp >= FileType_Invalid) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            return SNMP_ERR_GENERR;
        }
        config.fileTypeIndex = temp;
        fileListingTable_if_ctx_cache_set_expired();

        DEBUGMSGTL(("Interface", "%s: fileTypeIndex='%s'\n", __FUNCTION__, FileTypeIndexCurrent()));
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_fileTypeIndex\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_renameMediaFile(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info *reqinfo,
                       netsnmp_request_info *requests)
{
    int ret, val_len;
    char strTemp[512], *oldFilename, *newFilename;
    const char *pFileType;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *) "", 0);
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        val_len = requests->requestvb->val_len;
        if (val_len > 512) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGLENGTH);
            return SNMP_ERR_GENERR;
        }

        memcpy(&strTemp, requests->requestvb->val.string, val_len);
        strTemp[val_len] = 0;
        oldFilename = strTemp;
        if ((newFilename = strstr(oldFilename, ",")) == NULL) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGLENGTH);
            return SNMP_ERR_GENERR;
        }
        *newFilename++ = 0;
        pFileType = FileTypeIndexCurrent();

        DEBUGMSGTL(("Interface", "%s: oldFilename='%s' newFilename='%s' fileType='%s'\n",
                    __FUNCTION__, oldFilename, newFilename, pFileType));

        if (DBus_setProperty(SPBus_WebBrowser_DataCommSrv, "renameMediaFile", NULL,
                             DBUS_TYPE_STRING, &oldFilename,
                             DBUS_TYPE_STRING, &newFilename,
                             DBUS_TYPE_STRING, &pFileType,
                             DBUS_TYPE_INVALID) != 0)
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_renameMediaFile\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_deleteMediaFile(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info *reqinfo,
                       netsnmp_request_info *requests)
{
    int ret, val_len;
    char fileName[MAX_FILENAME_LEN + 1];
    const char *pFileType, *pFileName;

	//PRINT_BFILE_LINENO_NEWLINE;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *) "", 0);
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        val_len = requests->requestvb->val_len;
        if (val_len > MAX_FILENAME_LEN) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGLENGTH);
            return SNMP_ERR_GENERR;
        }
        memcpy(&fileName, requests->requestvb->val.string, val_len);
        fileName[val_len] = 0;
        pFileName = fileName;
        pFileType = FileTypeIndexCurrent();

        DEBUGMSGTL(("Interface", "%s: fileName='%s' fileType='%s'\n", __FUNCTION__, pFileName, pFileType));

        if (DBus_setProperty(SPBus_WebBrowser_DataCommSrv, "deleteMediaFile", NULL,
                             DBUS_TYPE_STRING, &pFileName,
                             DBUS_TYPE_STRING, &pFileType,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_deleteMediaFile\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_freeSpace(netsnmp_mib_handler *handler,
                 netsnmp_handler_registration *reginfo,
                 netsnmp_agent_request_info *reqinfo,
                 netsnmp_request_info *requests)
{
    int ret, iKBytes;
    int64_t integer64;

    UNUSED(handler);
    UNUSED(reginfo);
    UNUSED(requests);

    switch (reqinfo->mode) {
    case MODE_GET:
        if (DBus_getProperty(SPBus_WebBrowser_DataCommSrv, "getMediaFreeSpace", NULL,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_UINT64, &integer64,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }

        iKBytes = integer64 / 1024;
        DEBUGMSGTL(("Interface", "%s: getVal64='%lld' iKBytes='%d' \n",
                    __FUNCTION__, integer64, iKBytes));

        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&iKBytes, sizeof(iKBytes));
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_freeSpace\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_storeVideoFile(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests)
{
    int ret, val_len;
    char url[MAX_URL_LEN + 1];
    const char *pUrl, *pFileName, *pFileType;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *) "", 0);
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        val_len = requests->requestvb->val_len;
        if (val_len <= 0 || val_len > MAX_URL_LEN) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGLENGTH);
            break;
        }
        strncpy(url, (const char *)requests->requestvb->val.string, val_len);
        url[val_len] = 0;
        pUrl = url;

        pFileName = ParseUrlFilename(url);
        if (!pFileName) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGLENGTH);
            break;
        }
        pFileType = FileTypeString(FileType_Video);

        DEBUGMSGTL(("Interface", "%s: url='%s' pFileName='%s' pFileType='%s'\n",
                    __FUNCTION__, pUrl, pFileName, pFileType));

        if (DBus_setProperty(SPBus_WebBrowser_DataCommSrv, "DownloadFile", NULL,
                             DBUS_TYPE_STRING, &pUrl,
                             DBUS_TYPE_STRING, &pFileType,
                             DBUS_TYPE_STRING, &pFileName,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_storeVideoFile\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_storeAudioFile(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests)
{
    int ret, val_len;
    char url[MAX_URL_LEN + 1];
    const char *pUrl, *pFileName, *pFileType;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *) "", 0);
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        val_len = requests->requestvb->val_len;
        if (val_len <= 0 || val_len > MAX_URL_LEN) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGLENGTH);
            break;
        }
        strncpy(url, (const char *)requests->requestvb->val.string, val_len);
        url[val_len] = 0;
        pUrl = url;

        pFileName = ParseUrlFilename(url);
        if (pFileName == NULL) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGLENGTH);
            break;
        }

        pFileType = FileTypeString(FileType_Audio);

        DEBUGMSGTL(("Interface", "%s: url='%s' pFileName='%s' pFileType='%s'\n",
                    __FUNCTION__, pUrl, pFileName, pFileType));

        if (DBus_setProperty(SPBus_WebBrowser_DataCommSrv, "DownloadFile", NULL,
                             DBUS_TYPE_STRING, &pUrl,
                             DBUS_TYPE_STRING, &pFileType,
                             DBUS_TYPE_STRING, &pFileName,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_storeAudioFile\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_storeImageFile(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests)
{
    int ret, val_len;
    char url[MAX_URL_LEN + 1];
    const char *pUrl, *pFileName, *pFileType;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *) "", 0);
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        val_len = requests->requestvb->val_len;
        if (val_len <= 0 || val_len > MAX_URL_LEN) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGLENGTH);
            break;
        }
        strncpy(url, (const char *)requests->requestvb->val.string, val_len);
        url[val_len] = 0;
        pUrl = url;

        pFileName = ParseUrlFilename(url);
        if (pFileName == NULL) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }
        pFileType = FileTypeString(FileType_Picture);

        DEBUGMSGTL(("Interface", "%s: url='%s' pFileName='%s' pFileType='%s'\n",
                    __FUNCTION__, pUrl, pFileName, pFileType));

		//printf("Url=%s,FileType=%s,FileName=%s\n", pUrl, pFileType, pFileName);
        if (DBus_setProperty(SPBus_WebBrowser_DataCommSrv, "DownloadFile", NULL,
                             DBUS_TYPE_STRING, &pUrl,
                             DBUS_TYPE_STRING, &pFileType,
                             DBUS_TYPE_STRING, &pFileName,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_storeImageFile\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_targetPlaylistFile(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    int ret, val_len, playlistIndex;
    const char *ptr;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *) "", 0);
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        val_len = requests->requestvb->val_len;
        if (val_len > 4) {
            netsnmp_set_request_error (reqinfo, requests, SNMP_ERR_WRONGVALUE);
            return SNMP_ERR_GENERR;
        }
        ptr = (char *) requests->requestvb->val.string;
        if (toupper(*ptr) == 'H')
            config.playlistDevice = PT_HD;
        else if (toupper(*ptr) == 'F')
            config.playlistDevice = PT_FLASH;
        else if (toupper(*ptr) == 'R')
            config.playlistDevice = PT_RAM;
        else if (toupper(*ptr) == 'U')
            config.playlistDevice = PT_USB;
        else {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            return SNMP_ERR_GENERR;
        }
        ++ptr;
        playlistIndex = atoi(ptr);
        if ((config.playlistDevice == PT_HD && playlistIndex > 255) ||
            (config.playlistDevice == PT_FLASH && playlistIndex > 4) ||
            (config.playlistDevice == PT_RAM && playlistIndex > 5) ||
            (config.playlistDevice == PT_USB && playlistIndex > 255)) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            return SNMP_ERR_GENERR;
        }
        config.playlistIndex = playlistIndex;
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_targetPlaylistFile\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_storePlaylistFile(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests)
{
    int ret;
    char *pValue;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *) "", 0);
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        if (requests->requestvb->val_len > 512) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }
        pValue = netsnmp_strdup_and_null(requests->requestvb->val.string,
                                         requests->requestvb->val_len);
        DEBUGMSGTL(("Interface", "%s: setString='%s'\n", __FUNCTION__, pValue));

        if (DBus_setProperty(SPBus_WebBrowser_DataCommSrv, "setStorePlaylistFile", NULL,
                             DBUS_TYPE_STRING, &pValue,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        }
        SNMP_FREE(pValue);
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_storePlaylistFile\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_transferControl(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info *reqinfo,
                       netsnmp_request_info *requests)
{
	int iSnmpErrNo = SNMP_ERR_NOERROR, iRet;
    int ret, value;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
	{
		SharedPtr <CDBusMessage> DbusMsgCall_sp;
		DbusMsgCall_sp = CDBusMessage::createMethodCall(DBUS_SrvName_WebBrowser,
			DBUS_PATH_WebBrowser_DatCommSrv, DBUS_IF_WebBrowser_DataCommSrv, DBUS_METHOD_getTransferControl);
		if(DbusMsgCall_sp.isNull())
		{
			iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
			break;
		}
		SharedPtr <CDBusMessage> DbusMsgReply_sp;
		DbusMsgReply_sp = CDbusConnection::Call(connectToDBus(), DbusMsgCall_sp, (2*1000));
		if(DbusMsgReply_sp.isNull())
		{
			DbusMsgCall_sp = CDBusMessage::createMethodCall(DBUS_SrvName_ControlCenter,
				DBUS_PATH_WebBrowser_UiSrv, DBUS_IF_ControlCenter_UiSrv, DBUS_METHOD_getTransferControl);
			if(DbusMsgCall_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			DbusMsgReply_sp = CDbusConnection::Call(connectToDBus(), DbusMsgCall_sp, DBUS_CALL_DEFAULT_TIMEOUT_MS);
			if(DbusMsgReply_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
		}
		SharedPtr <CDBusParameterList> DbusParamListReceived_sp(new CDBusParameterList);
		if(DbusParamListReceived_sp.isNull())
		{
			iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
			break;
		}
		(*DbusParamListReceived_sp) << (*DbusMsgReply_sp);
		if(2 > DbusParamListReceived_sp->getSize())
		{
			iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
			break;
		}
		iRet = (*DbusParamListReceived_sp)[0]->toInt32();
		if(ERROR_SUCCESS != iRet)
		{
			iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
			break;
		}
		INT_t iTransferCtrlStatusCode = (*DbusParamListReceived_sp)[1]->toInt32();
		iRet = snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER, iTransferCtrlStatusCode);
		if(0 != iRet)
		{
			iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
			break;
		}
		break;		
	}

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        value = *requests->requestvb->val.integer;
        if (value != 0x87) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: setInt='%d'\n", __FUNCTION__, value));

        if (DBus_setProperty(SPBus_WebBrowser_DataCommSrv, "setTransferControl", NULL,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_transferControl\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return iSnmpErrNo;
}

int
handle_storeBrowserFile(netsnmp_mib_handler *handler,
                        netsnmp_handler_registration *reginfo,
                        netsnmp_agent_request_info *reqinfo,
                        netsnmp_request_info *requests)
{
    int ret, val_len;
    char url[MAX_URL_LEN + 1];
    const char *pUrl, *pFileName, *pFileType;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *) "", 0);
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        val_len = requests->requestvb->val_len;
        if (val_len <= 0 || val_len > MAX_URL_LEN) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGLENGTH);
            break;
        }
        strncpy(url, (const char *)requests->requestvb->val.string, val_len);
        url[val_len] = 0;
        pUrl = url;

        pFileName = ParseUrlFilename(url);
        if (pFileName == NULL) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGLENGTH);
            break;
        }

        pFileType = FileTypeString(FileType_Html);

        DEBUGMSGTL(("Interface", "%s: url='%s' pFileName='%s' pFileType='%s'\n",
                    __FUNCTION__, pUrl, pFileName, pFileType));

        if (DBus_setProperty(SPBus_WebBrowser_DataCommSrv, "DownloadFile", NULL,
                             DBUS_TYPE_STRING, &pUrl,
                             DBUS_TYPE_STRING, &pFileType,
                             DBUS_TYPE_STRING, &pFileName,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_storeBrowserFile\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_ftpPut(netsnmp_mib_handler *handler,
              netsnmp_handler_registration *reginfo,
              netsnmp_agent_request_info *reqinfo,
              netsnmp_request_info *requests)
{
    int ret, val_len;
    char strTmp[MAX_URL_LEN + 1];
    const char *pFileName, *pFileType, *pUrl;
    FileType type;
    char *p;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *) "", 0);
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        val_len = requests->requestvb->val_len;
        if (val_len > MAX_URL_LEN) {
            netsnmp_set_request_error (reqinfo, requests, SNMP_ERR_WRONGLENGTH);
            break;
        }
        strncpy(strTmp, (const char *)requests->requestvb->val.string, val_len);
        strTmp[val_len] = 0;
        p = strTmp;

        // filetype
        while (*p == ' ')
            p++;
        if (!strncasecmp(p, "VIDEO,", 6)) {
            type = FileType_Video;
            p += 6;
        } else if (!strncasecmp(p, "AUDIO,", 6)) {
            type = FileType_Audio;
            p += 6;
        } else if (!strncasecmp(p, "BROWSER,", 8)) {
            type = FileType_Html;
            p += 8;
        } else if (!strncasecmp(p, "PLAYLIST,", 9)) {
            type = FileType_Playlist;
            p += 9;
        } else if (!strncasecmp(p, "PICTURE,", 8)) {
            type = FileType_Picture;
            p += 8;
        } else if (!strncasecmp(p, "PROFILE,", 8)) {
            type = FileType_VideoProfile;
            p += 8;
        } else {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }
        while(*p == ' ')
            p++;

        // filename
        pFileName = p;
        p = strchr(p, ',');
        if (!p) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }
        *p++ = 0;
        while(*p == ' ')
            p++;

        // url
        pUrl = p;
        p = strchr(p, ',');
        if (p) {
            *p = 0;
        }

        pFileType = FileTypeString(type);

        DEBUGMSGTL(("Interface", "%s: url='%s' pFileName='%s' pFileType='%s'\n",
                    __FUNCTION__, pUrl, pFileName, pFileType));

        if (DBus_setProperty(SPBus_WebBrowser_DataCommSrv, "UploadFile", NULL,
                             DBUS_TYPE_STRING, &pFileName,
                             DBUS_TYPE_STRING, &pFileType,
                             DBUS_TYPE_STRING, &pUrl,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_ftpPut\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
