/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf 17337 2009-01-01 14:28:29Z magfr $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "subagent.h"
#include "gpio.h"
#include <DBusMessage.h>
#include <GpioBtnInputApi.h>
#include <DbusConnection.h>
#include <math2.h>

#ifdef	SRC_FILE_NAME
#undef	SRC_FILE_NAME
#endif	//SRC_FILE_NAME
#define	SRC_FILE_NAME			"gpio.c"

/** Initializes the gpio module */
void
init_gpio(void)
{
	int iRet = 0;
	
    const oid       gpioMode_oid[] = { 1, 3, 6, 1, 4, 1, 38010, 3, 7, 1 };
    const oid       j12GPIO1_oid[] = { 1, 3, 6, 1, 4, 1, 38010, 3, 7, 2 };
    const oid       j12GPIO2_oid[] = { 1, 3, 6, 1, 4, 1, 38010, 3, 7, 3 };
    const oid       j12All_oid[] = { 1, 3, 6, 1, 4, 1, 38010, 3, 7, 4 };
    const oid       j12PulseWidth_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 7, 5 };
    const oid       j12PulseHigh_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 7, 6 };
    const oid       j12PulseLow_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 7, 7 };
    const oid       j24SelectInput_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 7, 8 };
    const oid       j24ReadInput_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 7, 9 };
    const oid       j24ReadAll_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 7, 10 };
    const oid       j24SelectOutput_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 7, 11 };
    const oid       j24Output_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 7, 12 };
    const oid       j24WriteAll_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 7, 13 };
    const oid       j24InvertInput_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 7, 14 };
    const oid       j24InterruptControl_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 7, 15 };
    const oid       gpioTrapAddress_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 7, 16 };
    const oid       gpioDirection_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 7, 17 };
    const oid       gpioOutputData_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 7, 18 };
    const oid       gpioLedStatus_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 7, 19 };


    DEBUGMSGTL(("gpio", "Initializing\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("gpioMode", handle_gpioMode, gpioMode_oid,
                             OID_LENGTH(gpioMode_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("j12GPIO1", handle_j12GPIO1, j12GPIO1_oid,
                             OID_LENGTH(j12GPIO1_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("j12GPIO2", handle_j12GPIO2, j12GPIO2_oid,
                             OID_LENGTH(j12GPIO2_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("j12All", handle_j12All, j12All_oid,
                             OID_LENGTH(j12All_oid), HANDLER_CAN_RWRITE));
    iRet = netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("j12PulseWidth", handle_j12PulseWidth,
                             j12PulseWidth_oid,
                             OID_LENGTH(j12PulseWidth_oid),
                             HANDLER_CAN_RWRITE));
	if(MIB_REGISTERED_OK != iRet)
	{
		DEBUGMSGTL(("SnmpAgent", "[%s:%d]Ret=%d\n", SRC_FILE_NAME, __LINE__, iRet));
	}
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("j12PulseHigh", handle_j12PulseHigh,
                             j12PulseHigh_oid,
                             OID_LENGTH(j12PulseHigh_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("j12PulseLow", handle_j12PulseLow,
                             j12PulseLow_oid, OID_LENGTH(j12PulseLow_oid),
                             HANDLER_CAN_RWRITE));
    iRet = netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("j24SelectInput", handle_j24SelectInput,
                             j24SelectInput_oid,
                             OID_LENGTH(j24SelectInput_oid),
                             HANDLER_CAN_RWRITE));
	if(MIB_REGISTERED_OK != iRet)
	{
		DEBUGMSGTL(("SnmpAgent", "[%s:%d]Ret=%d\n", SRC_FILE_NAME, __LINE__, iRet));
	}
    iRet = netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("j24ReadInput", handle_j24ReadInput,
                             j24ReadInput_oid,
                             OID_LENGTH(j24ReadInput_oid),
                             HANDLER_CAN_RONLY));
	if(MIB_REGISTERED_OK != iRet)
	{
		DEBUGMSGTL(("SnmpAgent", "[%s:%d]Ret=%d\n", SRC_FILE_NAME, __LINE__, iRet));
	}
    iRet = netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("j24ReadAll", handle_j24ReadAll,
                             j24ReadAll_oid, OID_LENGTH(j24ReadAll_oid),
                             HANDLER_CAN_RONLY));
	if(MIB_REGISTERED_OK != iRet)
	{
		DEBUGMSGTL(("SnmpAgent", "[%s:%d]Ret=%d\n", SRC_FILE_NAME, __LINE__, iRet));
	}
    iRet = netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("j24SelectOutput", handle_j24SelectOutput,
                             j24SelectOutput_oid,
                             OID_LENGTH(j24SelectOutput_oid),
                             HANDLER_CAN_RWRITE));
	if(MIB_REGISTERED_OK != iRet)
	{
		DEBUGMSGTL(("SnmpAgent", "[%s:%d]Ret=%d\n", SRC_FILE_NAME, __LINE__, iRet));
	}
    iRet = netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("j24Output", handle_j24Output, j24Output_oid,
                             OID_LENGTH(j24Output_oid),
                             HANDLER_CAN_RWRITE));
	if(MIB_REGISTERED_OK != iRet)
	{
		DEBUGMSGTL(("SnmpAgent", "[%s:%d]Ret=%d\n", SRC_FILE_NAME, __LINE__, iRet));
	}
    iRet = netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("j24WriteAll", handle_j24WriteAll,
                             j24WriteAll_oid, OID_LENGTH(j24WriteAll_oid),
                             HANDLER_CAN_RWRITE));
	if(MIB_REGISTERED_OK != iRet)
	{
		DEBUGMSGTL(("SnmpAgent", "[%s:%d]Ret=%d\n", SRC_FILE_NAME, __LINE__, iRet));
	}
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("j24InvertInput", handle_j24InvertInput,
                             j24InvertInput_oid,
                             OID_LENGTH(j24InvertInput_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("j24InterruptControl",
                             handle_j24InterruptControl,
                             j24InterruptControl_oid,
                             OID_LENGTH(j24InterruptControl_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("gpioTrapAddress", handle_gpioTrapAddress,
                             gpioTrapAddress_oid,
                             OID_LENGTH(gpioTrapAddress_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("gpioDirection",
                             handle_gpioDirection,
                             gpioDirection_oid,
                             OID_LENGTH(gpioDirection_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("gpioOutputData",
                             handle_gpioOutputData,
                             gpioOutputData_oid,
                             OID_LENGTH(gpioOutputData_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("gpioLedStatus",
                             handle_gpioLedStatus,
                             gpioLedStatus_oid,
                             OID_LENGTH(gpioLedStatus_oid),
                             HANDLER_CAN_RWRITE));
}

int
handle_gpioMode(netsnmp_mib_handler *handler,
                netsnmp_handler_registration *reginfo,
                netsnmp_agent_request_info *reqinfo,
                netsnmp_request_info *requests)
{
    int             ret;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
#if 0
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)
                                 /* XXX: a pointer to the scalar's data */
                                 ,
                                 /*
                                  * XXX: the length of the data in bytes 
                                  */ );
#endif
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        if (0 /* XXX: error? */ ) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
        break;

    case MODE_SET_COMMIT:
        if (0 /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_gpioMode\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_j12GPIO1(netsnmp_mib_handler *handler,
                netsnmp_handler_registration *reginfo,
                netsnmp_agent_request_info *reqinfo,
                netsnmp_request_info *requests)
{
    int             ret;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
#if 0
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)
                                 /* XXX: a pointer to the scalar's data */
                                 ,
                                 /*
                                  * XXX: the length of the data in bytes 
                                  */ );
#endif
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        if (0 /* XXX: error? */ ) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
        break;

    case MODE_SET_COMMIT:
        if (0 /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_j12GPIO1\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_j12GPIO2(netsnmp_mib_handler *handler,
                netsnmp_handler_registration *reginfo,
                netsnmp_agent_request_info *reqinfo,
                netsnmp_request_info *requests)
{
    int             ret;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
#if 0
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)
                                 /* XXX: a pointer to the scalar's data */
                                 ,
                                 /*
                                  * XXX: the length of the data in bytes 
                                  */ );
#endif
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        if (0 /* XXX: error? */ ) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
        break;

    case MODE_SET_COMMIT:
        if (0 /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_j12GPIO2\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_j12All(netsnmp_mib_handler *handler,
              netsnmp_handler_registration *reginfo,
              netsnmp_agent_request_info *reqinfo,
              netsnmp_request_info *requests)
{
    int             ret;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
#if 0
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)
                                 /* XXX: a pointer to the scalar's data */
                                 ,
                                 /*
                                  * XXX: the length of the data in bytes 
                                  */ );
#endif
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        if (0 /* XXX: error? */ ) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
        break;

    case MODE_SET_COMMIT:
        if (0 /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_j12All\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_j12PulseWidth(netsnmp_mib_handler *handler,
                     netsnmp_handler_registration *reginfo,
                     netsnmp_agent_request_info *reqinfo,
                     netsnmp_request_info *requests)
{
	int iSnmpErrNo = SNMP_ERR_NOERROR;
	int iRet;
    int             ret;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
		case MODE_GET:
		{
			SharedPtr <CDBusMessage> DbusMsgCall_sp;
			DbusMsgCall_sp = CDBusMessage::createMethodCall(DBUS_GpioBtnInput_ServiceName,
				DBUS_GpioBtnInput_OBJECT_PATH, DBUS_GpioBtnInput_OBJECT_INTERFACE,
				DBUS_METHOD_getGpioOutputPulseWidth);
			if(DbusMsgCall_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			SharedPtr <CDBusMessage> DbusMsgReply_sp;
			DbusMsgReply_sp = CDbusConnection::Call(connectToDBus(), DbusMsgCall_sp, DBUS_CALL_DEFAULT_TIMEOUT_MS);
			if(DbusMsgReply_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			SharedPtr <CDBusParameterList> DbusParamListReceived_sp(new CDBusParameterList);
			if(DbusParamListReceived_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			(*DbusParamListReceived_sp) << (*DbusMsgReply_sp);
			if(2 > DbusParamListReceived_sp->getSize())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			iRet = (*DbusParamListReceived_sp)[0]->toInt32();
			if(ERROR_SUCCESS != iRet)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			INT_t iGpioOutputPulseWidth = (*DbusParamListReceived_sp)[1]->toInt32();
			iRet = snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER, iGpioOutputPulseWidth);
			if(0 != iRet)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			break;		
		}

	    case MODE_SET_RESERVE1:
	        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
	        if (ret != SNMP_ERR_NOERROR) {
	            netsnmp_set_request_error(reqinfo, requests, ret);
	        }
	        break;

	    case MODE_SET_RESERVE2:
	        break;

	    case MODE_SET_FREE:
	        break;

	    case MODE_SET_ACTION:
		{
			int iGpioOutputPulseWidth = *(requests->requestvb->val.integer);
			SharedPtr <CDBusMessage> DbusMsgCall_sp;
			DbusMsgCall_sp = CDBusMessage::createMethodCall(DBUS_GpioBtnInput_ServiceName,
				DBUS_GpioBtnInput_OBJECT_PATH, DBUS_GpioBtnInput_OBJECT_INTERFACE,
				DBUS_METHOD_setGpioOutputPulseWidth);
			if(DbusMsgCall_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			SharedPtr <CDBusParameterList> DbusParamListToSend_sp(new CDBusParameterList);
			if(DbusParamListToSend_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			try
			{
				(*DbusParamListToSend_sp) << iGpioOutputPulseWidth;
			}
			catch(std::bad_alloc & BadAllocEx)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			iRet = ((*DbusParamListToSend_sp) >> DbusMsgCall_sp);
			if(ERROR_SUCCESS != iRet)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}			
			SharedPtr <CDBusMessage> DbusMsgReply_sp;
			DbusMsgReply_sp = CDbusConnection::Call(connectToDBus(), DbusMsgCall_sp, DBUS_CALL_DEFAULT_TIMEOUT_MS);
			if(DbusMsgReply_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			SharedPtr <CDBusParameterList> DbusParamListReceived_sp(new CDBusParameterList);
			if(DbusParamListReceived_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			(*DbusParamListReceived_sp) << (*DbusMsgReply_sp);
			if(1 > DbusParamListReceived_sp->getSize())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			iRet = (*DbusParamListReceived_sp)[0]->toInt32();
			if(ERROR_SUCCESS != iRet)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			break;
		}
		case MODE_SET_COMMIT:
	        if (0 /* XXX: error? */ ) {
				/*
				* try _really_really_ hard to never get to this point 
				*/
	            netsnmp_set_request_error(reqinfo, requests,
	                                      SNMP_ERR_COMMITFAILED);
	        }
	        break;

	    case MODE_SET_UNDO:
	        break;

	    default:
			/*
			* we should never get here, so this is a really bad error 
			*/
	        snmp_log(LOG_ERR, "unknown mode (%d) in handle_j12PulseWidth\n",
	                 reqinfo->mode);
	        return SNMP_ERR_GENERR;
    }

    return iSnmpErrNo;
}

int
handle_j12PulseHigh(netsnmp_mib_handler *handler,
                    netsnmp_handler_registration *reginfo,
                    netsnmp_agent_request_info *reqinfo,
                    netsnmp_request_info *requests)
{
	int iSnmpErrNo = SNMP_ERR_NOERROR;
	int iRet;
    int             ret;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
	    case MODE_GET:
		{
			iRet = snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER, 0);
			if(0 != iRet)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
	        break;
	    }

	    case MODE_SET_RESERVE1:
	        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
	        if (ret != SNMP_ERR_NOERROR) {
	            netsnmp_set_request_error(reqinfo, requests, ret);
	        }
	        break;

	    case MODE_SET_RESERVE2:
	        break;

	    case MODE_SET_FREE:
	        break;

	    case MODE_SET_ACTION:
		{
			SharedPtr <CDBusMessage> DbusMsgCall_sp;
			DbusMsgCall_sp = CDBusMessage::createMethodCall(DBUS_GpioBtnInput_ServiceName,
				DBUS_GpioBtnInput_OBJECT_PATH, DBUS_GpioBtnInput_OBJECT_INTERFACE,
				DBUS_METHOD_GenerateGpioOutputTiming);
			if(DbusMsgCall_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			SharedPtr <CDBusParameterList> DbusParamListToSend_sp(new CDBusParameterList);
			if(DbusParamListToSend_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			try
			{
				(*DbusParamListToSend_sp) << 1;	//HIGH
			}
			catch(std::bad_alloc & BadAllocEx)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			iRet = ((*DbusParamListToSend_sp) >> DbusMsgCall_sp);
			if(ERROR_SUCCESS != iRet)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}			
			SharedPtr <CDBusMessage> DbusMsgReply_sp;
			DbusMsgReply_sp = CDbusConnection::Call(connectToDBus(), DbusMsgCall_sp, DBUS_CALL_DEFAULT_TIMEOUT_MS);
			if(DbusMsgReply_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			SharedPtr <CDBusParameterList> DbusParamListReceived_sp(new CDBusParameterList);
			if(DbusParamListReceived_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			(*DbusParamListReceived_sp) << (*DbusMsgReply_sp);
			if(1 > DbusParamListReceived_sp->getSize())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			iRet = (*DbusParamListReceived_sp)[0]->toInt32();
			if(ERROR_SUCCESS != iRet)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			break;
		}

	    case MODE_SET_COMMIT:
	        if (0 /* XXX: error? */ ) {
				/*
				* try _really_really_ hard to never get to this point 
				*/
	            netsnmp_set_request_error(reqinfo, requests,
	                                      SNMP_ERR_COMMITFAILED);
	        }
	        break;

	    case MODE_SET_UNDO:
	        break;

	    default:
			/*
			* we should never get here, so this is a really bad error 
			*/
	        snmp_log(LOG_ERR, "unknown mode (%d) in handle_j12PulseHigh\n",
	                 reqinfo->mode);
	        return SNMP_ERR_GENERR;
    }

    return iSnmpErrNo;
}

int
handle_j12PulseLow(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
	int iSnmpErrNo = SNMP_ERR_NOERROR;
	int iRet;
    int             ret;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
	    case MODE_GET:
		{
			iRet = snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER, 0);
			if(0 != iRet)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
	        break;
	    }

	    case MODE_SET_RESERVE1:
	        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
	        if (ret != SNMP_ERR_NOERROR) {
	            netsnmp_set_request_error(reqinfo, requests, ret);
	        }
	        break;

	    case MODE_SET_RESERVE2:
	        break;

	    case MODE_SET_FREE:
	        break;

	    case MODE_SET_ACTION:
		{
			SharedPtr <CDBusMessage> DbusMsgCall_sp;
			DbusMsgCall_sp = CDBusMessage::createMethodCall(DBUS_GpioBtnInput_ServiceName,
				DBUS_GpioBtnInput_OBJECT_PATH, DBUS_GpioBtnInput_OBJECT_INTERFACE,
				DBUS_METHOD_GenerateGpioOutputTiming);
			if(DbusMsgCall_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			SharedPtr <CDBusParameterList> DbusParamListToSend_sp(new CDBusParameterList);
			if(DbusParamListToSend_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			try
			{
				(*DbusParamListToSend_sp) << 0; //LOW
			}
			catch(std::bad_alloc & BadAllocEx)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			iRet = ((*DbusParamListToSend_sp) >> DbusMsgCall_sp);
			if(ERROR_SUCCESS != iRet)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}			
			SharedPtr <CDBusMessage> DbusMsgReply_sp;
			DbusMsgReply_sp = CDbusConnection::Call(connectToDBus(), DbusMsgCall_sp, DBUS_CALL_DEFAULT_TIMEOUT_MS);
			if(DbusMsgReply_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			SharedPtr <CDBusParameterList> DbusParamListReceived_sp(new CDBusParameterList);
			if(DbusParamListReceived_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			(*DbusParamListReceived_sp) << (*DbusMsgReply_sp);
			if(1 > DbusParamListReceived_sp->getSize())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			iRet = (*DbusParamListReceived_sp)[0]->toInt32();
			if(ERROR_SUCCESS != iRet)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			break;
		}

	    case MODE_SET_COMMIT:
	        if (0 /* XXX: error? */ ) {
				/*
				* try _really_really_ hard to never get to this point 
				*/
	            netsnmp_set_request_error(reqinfo, requests,
	                                      SNMP_ERR_COMMITFAILED);
	        }
	        break;

	    case MODE_SET_UNDO:
	        break;

	    default:
			/*
			* we should never get here, so this is a really bad error 
			*/
	        snmp_log(LOG_ERR, "unknown mode (%d) in handle_j12PulseLow\n",
	                 reqinfo->mode);
	        return SNMP_ERR_GENERR;
    }

    return iSnmpErrNo;
}

int
handle_j24SelectInput(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests)
{
	int iSnmpErrNo = SNMP_ERR_NOERROR;
	int iRet;
    int             ret;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
	    case MODE_GET:
		{
			SharedPtr <CDBusMessage> DbusMsgCall_sp;
			DbusMsgCall_sp = CDBusMessage::createMethodCall(DBUS_GpioBtnInput_ServiceName,
				DBUS_GpioBtnInput_OBJECT_PATH, DBUS_GpioBtnInput_OBJECT_INTERFACE,
				DBUS_METHOD_getSelectedInputGpioId);
			if(DbusMsgCall_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			SharedPtr <CDBusMessage> DbusMsgReply_sp;
			DbusMsgReply_sp = CDbusConnection::Call(connectToDBus(), DbusMsgCall_sp, DBUS_CALL_DEFAULT_TIMEOUT_MS);
			if(DbusMsgReply_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			SharedPtr <CDBusParameterList> DbusParamListReceived_sp(new CDBusParameterList);
			if(DbusParamListReceived_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			(*DbusParamListReceived_sp) << (*DbusMsgReply_sp);
			if(2 > DbusParamListReceived_sp->getSize())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			iRet = (*DbusParamListReceived_sp)[0]->toInt32();
			if(ERROR_SUCCESS != iRet)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			INT_t iSelectedInputGpioId = (*DbusParamListReceived_sp)[1]->toInt32();
			iRet = snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER, iSelectedInputGpioId);
			if(0 != iRet)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			break;		
		}

	    case MODE_SET_RESERVE1:
	        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
	        if (ret != SNMP_ERR_NOERROR) {
	            netsnmp_set_request_error(reqinfo, requests, ret);
	        }
	        break;

	    case MODE_SET_RESERVE2:
	        break;

	    case MODE_SET_FREE:
	        break;

	    case MODE_SET_ACTION:
		{
			int iGpioId = *(requests->requestvb->val.integer);
			SharedPtr <CDBusMessage> DbusMsgCall_sp;
			DbusMsgCall_sp = CDBusMessage::createMethodCall(DBUS_GpioBtnInput_ServiceName,
				DBUS_GpioBtnInput_OBJECT_PATH, DBUS_GpioBtnInput_OBJECT_INTERFACE,
				DBUS_METHOD_selectInputGpioId);
			if(DbusMsgCall_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			SharedPtr <CDBusParameterList> DbusParamListToSend_sp(new CDBusParameterList);
			if(DbusParamListToSend_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			try
			{
				(*DbusParamListToSend_sp) << iGpioId;
			}
			catch(std::bad_alloc & BadAllocEx)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			iRet = ((*DbusParamListToSend_sp) >> DbusMsgCall_sp);
			if(ERROR_SUCCESS != iRet)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}			
			SharedPtr <CDBusMessage> DbusMsgReply_sp;
			DbusMsgReply_sp = CDbusConnection::Call(connectToDBus(), DbusMsgCall_sp, DBUS_CALL_DEFAULT_TIMEOUT_MS);
			if(DbusMsgReply_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			SharedPtr <CDBusParameterList> DbusParamListReceived_sp(new CDBusParameterList);
			if(DbusParamListReceived_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			(*DbusParamListReceived_sp) << (*DbusMsgReply_sp);
			if(1 > DbusParamListReceived_sp->getSize())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			iRet = (*DbusParamListReceived_sp)[0]->toInt32();
			if(ERROR_SUCCESS != iRet)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			break;
		}

	    case MODE_SET_COMMIT:
	        if (0 /* XXX: error? */ ) {
			/*
			* try _really_really_ hard to never get to this point 
			*/
	            netsnmp_set_request_error(reqinfo, requests,
	                                      SNMP_ERR_COMMITFAILED);
	        }
	        break;

	    case MODE_SET_UNDO:
	        break;

	    default:
			/*
			* we should never get here, so this is a really bad error 
			*/
	        snmp_log(LOG_ERR, "unknown mode (%d) in handle_j24SelectInput\n",
	                 reqinfo->mode);
	        return SNMP_ERR_GENERR;
    }

    return iSnmpErrNo;
}

int
handle_j24ReadInput(netsnmp_mib_handler *handler,
                    netsnmp_handler_registration *reginfo,
                    netsnmp_agent_request_info *reqinfo,
                    netsnmp_request_info *requests)
{
	int iSnmpErrNo = SNMP_ERR_NOERROR;
	int iRet;

    UNUSED(handler);
    UNUSED(reginfo);
    UNUSED(requests);

    switch (reqinfo->mode) {
	    case MODE_GET:
		{
			SharedPtr <CDBusMessage> DbusMsgCall_sp;
			DbusMsgCall_sp = CDBusMessage::createMethodCall(DBUS_GpioBtnInput_ServiceName,
				DBUS_GpioBtnInput_OBJECT_PATH, DBUS_GpioBtnInput_OBJECT_INTERFACE,
				DBUS_METHOD_readGpioInputStatus);
			if(DbusMsgCall_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			SharedPtr <CDBusMessage> DbusMsgReply_sp;
			DbusMsgReply_sp = CDbusConnection::Call(connectToDBus(), DbusMsgCall_sp, DBUS_CALL_DEFAULT_TIMEOUT_MS);
			if(DbusMsgReply_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			SharedPtr <CDBusParameterList> DbusParamListReceived_sp(new CDBusParameterList);
			if(DbusParamListReceived_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			(*DbusParamListReceived_sp) << (*DbusMsgReply_sp);
			if(2 > DbusParamListReceived_sp->getSize())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			iRet = (*DbusParamListReceived_sp)[0]->toInt32();
			if(ERROR_SUCCESS != iRet)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			INT_t iGpioLogicalStatus = (*DbusParamListReceived_sp)[1]->toInt32();
			iRet = snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER, iGpioLogicalStatus);
			if(0 != iRet)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			break;		
		}
	    default:
		{
			/*
			* we should never get here, so this is a really bad error 
			*/
	        snmp_log(LOG_ERR, "unknown mode (%d) in handle_j24ReadInput\n",
	                 reqinfo->mode);
	        return SNMP_ERR_GENERR;
	    }
    }

    return iSnmpErrNo;
}

int
handle_j24ReadAll(netsnmp_mib_handler *handler,
				  netsnmp_handler_registration *reginfo,
				  netsnmp_agent_request_info *reqinfo,
				  netsnmp_request_info *requests)
{
	int iOutRet = SNMP_ERR_NOERROR, iRet;
	UNUSED(handler);
	UNUSED(reginfo);
	UNUSED(requests);
	
	switch (reqinfo->mode) {
		case MODE_GET:
		{
			SharedPtr <CDBusMessage> DbusMsgCall_sp;
			DbusMsgCall_sp = CDBusMessage::createMethodCall(DBUS_GpioBtnInput_ServiceName,
				DBUS_GpioBtnInput_OBJECT_PATH, DBUS_GpioBtnInput_OBJECT_INTERFACE,
				DBUS_METHOD_getGpioInputStatus);
			if(DbusMsgCall_sp.isNull())
			{
				iOutRet = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			SharedPtr <CDBusMessage> DbusMsgReply_sp;
			DbusMsgReply_sp = CDbusConnection::Call(connectToDBus(), DbusMsgCall_sp, DBUS_CALL_DEFAULT_TIMEOUT_MS);
			if(DbusMsgReply_sp.isNull())
			{
				iOutRet = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			SharedPtr <CDBusParameterList> DbusParamListReceived_sp(new CDBusParameterList);
			if(DbusParamListReceived_sp.isNull())
			{
				iOutRet = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			(*DbusParamListReceived_sp) << (*DbusMsgReply_sp);
			if(2 > DbusParamListReceived_sp->getSize())
			{
				iOutRet = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			iRet = (*DbusParamListReceived_sp)[0]->toInt32();
			if(ERROR_SUCCESS != iRet)
			{
				iOutRet = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			CString strGpioInputStatus = (*DbusParamListReceived_sp)[1]->toString();
			iRet = snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, 
				(LPCSTR)strGpioInputStatus, strGpioInputStatus.GetStrLength());
			if(0 != iRet)
			{
				iOutRet = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			break;		
		}
		default:
			/*
			* we should never get here, so this is a really bad error 
			*/
			snmp_log(LOG_ERR, "unknown mode (%d) in handle_j24ReadAll\n",
				reqinfo->mode);
			return SNMP_ERR_GENERR;
	}
	
	return iOutRet;
}

int
handle_j24SelectOutput(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info *reqinfo,
                       netsnmp_request_info *requests)
{
	int iSnmpErrNo = SNMP_ERR_NOERROR;
	int iRet;
    int             ret;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
	    case MODE_GET:
		{
			SharedPtr <CDBusMessage> DbusMsgCall_sp;
			DbusMsgCall_sp = CDBusMessage::createMethodCall(DBUS_GpioBtnInput_ServiceName,
				DBUS_GpioBtnInput_OBJECT_PATH, DBUS_GpioBtnInput_OBJECT_INTERFACE,
				DBUS_METHOD_getSelectedOutputGpioId);
			if(DbusMsgCall_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			SharedPtr <CDBusMessage> DbusMsgReply_sp;
			DbusMsgReply_sp = CDbusConnection::Call(connectToDBus(), DbusMsgCall_sp, DBUS_CALL_DEFAULT_TIMEOUT_MS);
			if(DbusMsgReply_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			SharedPtr <CDBusParameterList> DbusParamListReceived_sp(new CDBusParameterList);
			if(DbusParamListReceived_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			(*DbusParamListReceived_sp) << (*DbusMsgReply_sp);
			if(2 > DbusParamListReceived_sp->getSize())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			iRet = (*DbusParamListReceived_sp)[0]->toInt32();
			if(ERROR_SUCCESS != iRet)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			INT_t iSelectedOutputGpioId = (*DbusParamListReceived_sp)[1]->toInt32();
			iRet = snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER, iSelectedOutputGpioId);
			if(0 != iRet)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			break;		
		}

	    case MODE_SET_RESERVE1:
	        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
	        if (ret != SNMP_ERR_NOERROR) {
	            netsnmp_set_request_error(reqinfo, requests, ret);
	        }
	        break;

	    case MODE_SET_RESERVE2:
	        break;

	    case MODE_SET_FREE:
	        break;

	    case MODE_SET_ACTION:
		{
			int iGpioId = *(requests->requestvb->val.integer);
			SharedPtr <CDBusMessage> DbusMsgCall_sp;
			DbusMsgCall_sp = CDBusMessage::createMethodCall(DBUS_GpioBtnInput_ServiceName,
				DBUS_GpioBtnInput_OBJECT_PATH, DBUS_GpioBtnInput_OBJECT_INTERFACE,
				DBUS_METHOD_selectOutputGpioId);
			if(DbusMsgCall_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			SharedPtr <CDBusParameterList> DbusParamListToSend_sp(new CDBusParameterList);
			if(DbusParamListToSend_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			try
			{
				(*DbusParamListToSend_sp) << iGpioId;
			}
			catch(std::bad_alloc & BadAllocEx)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			iRet = ((*DbusParamListToSend_sp) >> DbusMsgCall_sp);
			if(ERROR_SUCCESS != iRet)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}			
			SharedPtr <CDBusMessage> DbusMsgReply_sp;
			DbusMsgReply_sp = CDbusConnection::Call(connectToDBus(), DbusMsgCall_sp, DBUS_CALL_DEFAULT_TIMEOUT_MS);
			if(DbusMsgReply_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			SharedPtr <CDBusParameterList> DbusParamListReceived_sp(new CDBusParameterList);
			if(DbusParamListReceived_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			(*DbusParamListReceived_sp) << (*DbusMsgReply_sp);
			if(1 > DbusParamListReceived_sp->getSize())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			iRet = (*DbusParamListReceived_sp)[0]->toInt32();
			if(ERROR_SUCCESS != iRet)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			break;
		}

	    case MODE_SET_COMMIT:
	        if (0 /* XXX: error? */ ) {
				/*
				* try _really_really_ hard to never get to this point 
				*/
	            netsnmp_set_request_error(reqinfo, requests,
	                                      SNMP_ERR_COMMITFAILED);
	        }
	        break;

	    case MODE_SET_UNDO:
	        break;

	    default:
			/*
			* we should never get here, so this is a really bad error 
			*/
	        snmp_log(LOG_ERR, "unknown mode (%d) in handle_j24SelectOutput\n",
	                 reqinfo->mode);
	        return SNMP_ERR_GENERR;
    }

    return iSnmpErrNo;
}

int
handle_j24Output(netsnmp_mib_handler *handler,
                 netsnmp_handler_registration *reginfo,
                 netsnmp_agent_request_info *reqinfo,
                 netsnmp_request_info *requests)
{
	int iSnmpErrNo = SNMP_ERR_NOERROR;
	int iRet;
    int             ret;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
	    case MODE_GET:
		{
			iRet = snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER, 0);
			if(0 != iRet)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
	        break;
	    }

	    case MODE_SET_RESERVE1:
	        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
	        if (ret != SNMP_ERR_NOERROR) {
	            netsnmp_set_request_error(reqinfo, requests, ret);
	        }
	        break;

	    case MODE_SET_RESERVE2:
	        break;

	    case MODE_SET_FREE:
	        break;

	    case MODE_SET_ACTION:
		{
			int iGpioBitStatus = *(requests->requestvb->val.integer);
			SharedPtr <CDBusMessage> DbusMsgCall_sp;
			DbusMsgCall_sp = CDBusMessage::createMethodCall(DBUS_GpioBtnInput_ServiceName,
				DBUS_GpioBtnInput_OBJECT_PATH, DBUS_GpioBtnInput_OBJECT_INTERFACE,
				DBUS_METHOD_setGpioOutputSingleBit);
			if(DbusMsgCall_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			SharedPtr <CDBusParameterList> DbusParamListToSend_sp(new CDBusParameterList);
			if(DbusParamListToSend_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			try
			{
				(*DbusParamListToSend_sp) << iGpioBitStatus;
			}
			catch(std::bad_alloc & BadAllocEx)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			iRet = ((*DbusParamListToSend_sp) >> DbusMsgCall_sp);
			if(ERROR_SUCCESS != iRet)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}			
			SharedPtr <CDBusMessage> DbusMsgReply_sp;
			DbusMsgReply_sp = CDbusConnection::Call(connectToDBus(), DbusMsgCall_sp, DBUS_CALL_DEFAULT_TIMEOUT_MS);
			if(DbusMsgReply_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			SharedPtr <CDBusParameterList> DbusParamListReceived_sp(new CDBusParameterList);
			if(DbusParamListReceived_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			(*DbusParamListReceived_sp) << (*DbusMsgReply_sp);
			if(1 > DbusParamListReceived_sp->getSize())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			iRet = (*DbusParamListReceived_sp)[0]->toInt32();
			if(ERROR_SUCCESS != iRet)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			break;
		}

	    case MODE_SET_COMMIT:
	        if (0 /* XXX: error? */ ) {
				/*
				* try _really_really_ hard to never get to this point 
				*/
	            netsnmp_set_request_error(reqinfo, requests,
	                                      SNMP_ERR_COMMITFAILED);
	        }
	        break;

	    case MODE_SET_UNDO:
	        break;

	    default:
			/*
			* we should never get here, so this is a really bad error 
			*/
	        snmp_log(LOG_ERR, "unknown mode (%d) in handle_j24Output\n",
	                 reqinfo->mode);
	        return SNMP_ERR_GENERR;
    }

    return iSnmpErrNo;
}

int
handle_j24WriteAll(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
	int iSnmpErrNo = SNMP_ERR_NOERROR;
	int iRet;
    int             ret;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
	    case MODE_GET:
		{
			iRet = snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER, 0);
			if(0 != iRet)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
	        break;
	    }
	    case MODE_SET_RESERVE1:
	        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
	        if (ret != SNMP_ERR_NOERROR) {
	            netsnmp_set_request_error(reqinfo, requests, ret);
	        }
	        break;

	    case MODE_SET_RESERVE2:
	        break;

	    case MODE_SET_FREE:
	        break;

	    case MODE_SET_ACTION:
		{
			char szGpioOutputStatusToSet[32];
			size_t iStrLen = requests->requestvb->val_len;
			memcpy(szGpioOutputStatusToSet, requests->requestvb->val.string, GET_MIN_VAL(sizeof(szGpioOutputStatusToSet)-1, iStrLen));
			szGpioOutputStatusToSet[GET_MIN_VAL(sizeof(szGpioOutputStatusToSet)-1, iStrLen)] = '\0';
			SharedPtr <CDBusMessage> DbusMsgCall_sp;
			DbusMsgCall_sp = CDBusMessage::createMethodCall(DBUS_GpioBtnInput_ServiceName,
				DBUS_GpioBtnInput_OBJECT_PATH, DBUS_GpioBtnInput_OBJECT_INTERFACE,
				DBUS_METHOD_setGpioOutputStatus);
			if(DbusMsgCall_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			SharedPtr <CDBusParameterList> DbusParamListToSend_sp(new CDBusParameterList);
			if(DbusParamListToSend_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			try
			{
				(*DbusParamListToSend_sp) << szGpioOutputStatusToSet;
			}
			catch(std::bad_alloc & BadAllocEx)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			iRet = ((*DbusParamListToSend_sp) >> DbusMsgCall_sp);
			if(ERROR_SUCCESS != iRet)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}			
			SharedPtr <CDBusMessage> DbusMsgReply_sp;
			DbusMsgReply_sp = CDbusConnection::Call(connectToDBus(), DbusMsgCall_sp, DBUS_CALL_DEFAULT_TIMEOUT_MS);
			if(DbusMsgReply_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			SharedPtr <CDBusParameterList> DbusParamListReceived_sp(new CDBusParameterList);
			if(DbusParamListReceived_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			(*DbusParamListReceived_sp) << (*DbusMsgReply_sp);
			if(1 > DbusParamListReceived_sp->getSize())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			iRet = (*DbusParamListReceived_sp)[0]->toInt32();
			if(ERROR_SUCCESS != iRet)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
	        break;
	    }
	    case MODE_SET_COMMIT:
	        if (0 /* XXX: error? */ ) {
				/*
				* try _really_really_ hard to never get to this point 
				*/
	            netsnmp_set_request_error(reqinfo, requests,
	                                      SNMP_ERR_COMMITFAILED);
	        }
	        break;

	    case MODE_SET_UNDO:
	        break;

	    default:
			/*
			* we should never get here, so this is a really bad error 
			*/
	        snmp_log(LOG_ERR, "unknown mode (%d) in handle_j24WriteAll\n",
	                 reqinfo->mode);
	        return SNMP_ERR_GENERR;
	}

    return iSnmpErrNo;
}

int
handle_j24InvertInput(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests)
{
    int             ret;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
#if 0
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)
                                 /* XXX: a pointer to the scalar's data */
                                 ,
                                 /*
                                  * XXX: the length of the data in bytes 
                                  */ );
#endif
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        if (0 /* XXX: error? */ ) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
        break;

    case MODE_SET_COMMIT:
        if (0 /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_j24InvertInput\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_j24InterruptControl(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests)
{
    int             ret;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
#if 0
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)
                                 /* XXX: a pointer to the scalar's data */
                                 ,
                                 /*
                                  * XXX: the length of the data in bytes 
                                  */ );
#endif
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        if (0 /* XXX: error? */ ) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
        break;

    case MODE_SET_COMMIT:
        if (0 /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_j24InterruptControl\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_gpioTrapAddress(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info *reqinfo,
                       netsnmp_request_info *requests)
{
    int             ret;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
#if 0
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)
                                 /* XXX: a pointer to the scalar's data */
                                 ,
                                 /*
                                  * XXX: the length of the data in bytes 
                                  */ );
#endif
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        if (0 /* XXX: error? */ ) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
        break;

    case MODE_SET_COMMIT:
        if (0 /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_gpioTrapAddress\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_gpioDirection(netsnmp_mib_handler *handler,
                     netsnmp_handler_registration *reginfo,
                     netsnmp_agent_request_info *reqinfo,
                     netsnmp_request_info *requests)
{
    int ret, value;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        if (DBus_getProperty(SPBus_GpioBtnInput, "getGpioDirection", NULL,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_UINT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: getInt='%d'\n", __FUNCTION__, value));

        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value, sizeof(value));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        value = *requests->requestvb->val.integer;
        DEBUGMSGTL(("Interface", "%s: setInt='%d'\n", __FUNCTION__, value));

        if (DBus_setProperty(SPBus_GpioBtnInput, "setGpioDirection", NULL,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_gpioDirection\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_gpioOutputData(netsnmp_mib_handler *handler,
                     netsnmp_handler_registration *reginfo,
                     netsnmp_agent_request_info *reqinfo,
                     netsnmp_request_info *requests)
{
    int ret, value;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        value = 0;
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value, sizeof(value));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        value = *requests->requestvb->val.integer;
        DEBUGMSGTL(("Interface", "%s: setInt='%d'\n", __FUNCTION__, value));

        if (DBus_setProperty(SPBus_GpioBtnInput, "setGpioOutputData", NULL,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_gpioDirection\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
handle_gpioLedStatus(netsnmp_mib_handler *handler,
                     netsnmp_handler_registration *reginfo,
                     netsnmp_agent_request_info *reqinfo,
                     netsnmp_request_info *requests)
{
    int ret, value;
    SPArgs args;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        value = 0;
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value, sizeof(value));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        value = *requests->requestvb->val.integer;
        DEBUGMSGTL(("Interface", "%s: setInt='%d'\n", __FUNCTION__, value));

        args.eType = SPValue_Integer;
        if (DBus_setProperty(SPBus_MPlayer, "setGpioLedStatus", &args,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: getDBusValue='0x%x'\n", __FUNCTION__, args.integer));
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_gpioDirection\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

