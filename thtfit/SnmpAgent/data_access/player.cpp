/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf 17337 2009-01-01 14:28:29Z magfr $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "subagent.h"
#include "player.h"
#include <WebBrowserAppDef.h>
#include <DbusConnection.h>


#ifdef	SRC_FILE_NAME
#undef	SRC_FILE_NAME
#endif	//SRC_FILE_NAME
#define	SRC_FILE_NAME			"player.c"

typedef struct {
    ActiveMedia_TYPE eDevType;
    FileType eFileType;
    char fileName[MAX_FILENAME_LEN + 1];
    int iPlayLoop;
    int iPlaySec;
} PCmdValue;

int ParsePlayCmd(const char *cmd, int length, PCmdValue *v)
{
    const char *pFileName, *p;
    unsigned int iFileName;

    // device type
    p = cmd;
    if (!strncasecmp(p, "flash::", 7)) {
        v->eDevType = AMedia_TYPE_FLASH;
        p += 7;
    } else if (!strncasecmp(p, "sdcard::", 8)) {
        v->eDevType = AMedia_TYPE_SdCard;
        p += 8;
    }  else if (!strncasecmp(p, "usb::", 5)) {
        v->eDevType = AMedia_TYPE_USB;
        p += 5;
    }  else if (!strncasecmp(p, "hdd::", 5)) {
        v->eDevType = AMedia_TYPE_HDD;
        p += 5;
    }  else if (!strncasecmp(p, "ide::", 5)) {
        v->eDevType = AMedia_TYPE_FLASH;
        p += 5;
    }  else if (!strncasecmp(p, "ram::", 5)) {
        v->eDevType = AMedia_TYPE_RAM;
        p += 5;
    } else if (!strncasecmp(p, "http://", 7)) {
        v->eDevType = AMedia_TYPE_URL;
        v->eFileType = FileType_HTTP;
        p += 7;
        goto nextstep;
    } else if (!strncasecmp(p, "udp://", 6)) {
        v->eDevType = AMedia_TYPE_URL;
        v->eFileType = FileType_UDP;
        p += 6;
        goto nextstep;
    } else if (!strncasecmp(p, "rtp://", 6)) {
        v->eDevType = AMedia_TYPE_URL;
        v->eFileType = FileType_RTP;
        p += 6;
        goto nextstep;
    } else {
        v->eDevType = AMedia_TYPE_Unknown;
        DEBUGMSGTL(("Interface", "ERROR: %s: Not yet supported: rtsp tuner\n", __FUNCTION__));
        return FALSE;
    }

    // file type
    if (!strncasecmp(p, "video://", 8)) {
        v->eFileType = FileType_Video;
        p += 8;
    } else if (!strncasecmp(p, "audio://", 8)) {
        v->eFileType = FileType_Audio;
        p += 8;
    } else if (!strncasecmp(p, "picture://", 10)) {
        v->eFileType = FileType_Picture;
        p += 10;
    } else if (!strncasecmp(p, "browser://", 10)) {
        v->eFileType = FileType_Html;
        p += 10;
    } else {
        v->eFileType = FileType_Unknown;
        DEBUGMSGTL(("Interface", "ERROR: %s: Unknown file types\n", __FUNCTION__));
        return FALSE;
    }

nextstep:
    // filename
    v->iPlayLoop = 1;
    v->iPlaySec  = 0;
    pFileName = p;
    p = strchr(pFileName, '?');
    if (!p) {
        iFileName = length - (pFileName - cmd);
    } else {
        iFileName = p - pFileName;
        p = strstr(pFileName, "?loop=");
        if (p) {
            p += 6;
            v->iPlayLoop = atoi(p);
        }
        p = strstr(pFileName, "?duration=");
        if (p) {
            p += 10;
            v->iPlaySec = atoi(p);
        }
    }

    if (iFileName > MAX_FILENAME_LEN) {
        DEBUGMSGTL(("Interface", "ERROR: %s: filename too long\n", __FUNCTION__));
        return FALSE;
    }
    strncpy(v->fileName, pFileName, iFileName);
    v->fileName[iFileName] = 0;
    return TRUE;
}

/** Initializes the player module */
void
init_player(void)
{
	INT_t iRet = 0;
	
    const oid       currentItemBeingPlayed_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 1 };
    const oid       flippingInterval_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 2 };
    const oid       playVirtualChannel_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 3 };
    const oid       playInternalImage_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 4 };
    const oid       playPlaylist_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 5 };
    const oid       playMedia_oid[] = { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 6 };
    const oid       playNextFile_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 7 };
    const oid       playerState_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 8 };
    const oid       playMode_oid[] = { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 9 };
    const oid       virtualChannelID_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 10 };
    const oid       virtualChannelMedia_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 11 };
    const oid       videoType_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 12 };
    const oid       audioType_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 13 };
    const oid       audioSampFreq_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 14 };
    const oid       defaultStartupItem_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 15 };
    const oid       currentFrameCount_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 16 };
    const oid       defaultIdlePlaylist_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 17 };
    const oid       idleDetect_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 18 };
    const oid       playerVolume_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 19 };
    const oid       playerMute_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 20 };
    const oid       speedControl_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 21 };
    const oid       videoSysType_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 22 };
    const oid       coordinateMode_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 23 };
    const oid       xPosition_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 24 };
    const oid       yPosition_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 25 };
    const oid       xSize_oid[] = { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 26 };
    const oid       ySize_oid[] = { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 27 };
    const oid       videoMode_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 28 };
    const oid       alphaLayer_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 29 };
    const oid       activeLayer_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 30 };
    const oid       playBrowser_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 31 };
    const oid       playLayer_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 32 };
    const oid       videoPID_oid[] = { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 33 };
    const oid       audioPID_oid[] = { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 34 };
    const oid       playerBrightness_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 35 };
    const oid       playerContrast_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 36 };
    const oid       playerColor_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 37 };
    const oid       playerTint_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 38 };
    const oid       horizontalSize_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 39 };
    const oid       horizontalShift_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 40 };
    const oid       verticalSize_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 41 };
    const oid       verticalShift_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 42 };
    const oid       networkBurstBufferSize_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 43 };
    const oid       videoJitterSize_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 44 };
    const oid       rtspKeepAlive_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 45 };
    const oid       virtualChannelAlias_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 46 };
    const oid       virtualChannelDisplayPosition_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 47 };
    const oid       virtualChannelEnable_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 48 };
    const oid       virtualChannelMin_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 49 };
    const oid       virtualChannelMax_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 50 };
    const oid       virtualChannelDisplayDuration_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 51 };
    const oid       videoProfileEnable_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 52 };
    const oid       videoProfileRegister_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 53 };
    const oid       closedCaption_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 54 };
    const oid       bootSplashPlayUrl_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 55 };
    const oid       videoSyncMode_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 56 };
    const oid       videoSyncMaster_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 57 };
    const oid       outputSpdifMode_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 58 };
    const oid       Html_EvalJavascript_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 59 };
    const oid       VideoLayerPlayMedia_oid[] =
		{ 1, 3, 6, 1, 4, 1, 38010, 3, 3, 60 };
    const oid       HtmlLayerPlay_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 61 };
    const oid       playNext_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 62 };
    const oid       videoRotation_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 63 };
	const oid       playerColorSpace_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 64 };
	const oid       playerColorDepth_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 65 };
	const oid       playerMatrixcoefficients_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 66 };
	const oid       playSmooth_oid[] =
    { 1, 3, 6, 1, 4, 1, 38010, 3, 3, 67 };
	
    DEBUGMSGTL(("player", "Initializing\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("currentItemBeingPlayed",
                             handle_currentItemBeingPlayed,
                             currentItemBeingPlayed_oid,
                             OID_LENGTH(currentItemBeingPlayed_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("flippingInterval", handle_flippingInterval,
                             flippingInterval_oid,
                             OID_LENGTH(flippingInterval_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("playVirtualChannel",
                             handle_playVirtualChannel,
                             playVirtualChannel_oid,
                             OID_LENGTH(playVirtualChannel_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("playInternalImage", handle_playInternalImage,
                             playInternalImage_oid,
                             OID_LENGTH(playInternalImage_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("playPlaylist", handle_playPlaylist,
                             playPlaylist_oid,
                             OID_LENGTH(playPlaylist_oid),
                             HANDLER_CAN_RWRITE));
	iRet = netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("playMedia", handle_playMedia, playMedia_oid,
                             OID_LENGTH(playMedia_oid),
                             HANDLER_CAN_RWRITE));
	if(MIB_REGISTERED_OK != iRet)
	{
		DEBUGMSGTL(("SnmpAgent", "[%s:%d]Ret=%d\n", SRC_FILE_NAME, __LINE__, iRet));
	}
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("playNextFile", handle_playNextFile,
                             playNextFile_oid,
                             OID_LENGTH(playNextFile_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("playerState", handle_playerState,
                             playerState_oid, OID_LENGTH(playerState_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("playMode", handle_playMode, playMode_oid,
                             OID_LENGTH(playMode_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("virtualChannelID", handle_virtualChannelID,
                             virtualChannelID_oid,
                             OID_LENGTH(virtualChannelID_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("virtualChannelMedia",
                             handle_virtualChannelMedia,
                             virtualChannelMedia_oid,
                             OID_LENGTH(virtualChannelMedia_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("videoType", handle_videoType, videoType_oid,
                             OID_LENGTH(videoType_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("audioType", handle_audioType, audioType_oid,
                             OID_LENGTH(audioType_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("audioSampFreq", handle_audioSampFreq,
                             audioSampFreq_oid,
                             OID_LENGTH(audioSampFreq_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("defaultStartupItem",
                             handle_defaultStartupItem,
                             defaultStartupItem_oid,
                             OID_LENGTH(defaultStartupItem_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("currentFrameCount", handle_currentFrameCount,
                             currentFrameCount_oid,
                             OID_LENGTH(currentFrameCount_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("defaultIdlePlaylist",
                             handle_defaultIdlePlaylist,
                             defaultIdlePlaylist_oid,
                             OID_LENGTH(defaultIdlePlaylist_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("idleDetect", handle_idleDetect,
                             idleDetect_oid, OID_LENGTH(idleDetect_oid),
                             HANDLER_CAN_RWRITE));
    iRet = netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("playerVolume", handle_playerVolume,
                             playerVolume_oid,
                             OID_LENGTH(playerVolume_oid),
                             HANDLER_CAN_RWRITE));
	if(MIB_REGISTERED_OK != iRet)
	{
		DEBUGMSGTL(("SnmpAgent", "[%s:%d]Ret=%d\n", SRC_FILE_NAME, __LINE__, iRet));
	}
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("playerMute", handle_playerMute,
                             playerMute_oid, OID_LENGTH(playerMute_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("speedControl", handle_speedControl,
                             speedControl_oid,
                             OID_LENGTH(speedControl_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("videoSysType", handle_videoSysType,
                             videoSysType_oid,
                             OID_LENGTH(videoSysType_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("coordinateMode", handle_coordinateMode,
                             coordinateMode_oid,
                             OID_LENGTH(coordinateMode_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("xPosition", handle_xPosition, xPosition_oid,
                             OID_LENGTH(xPosition_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("yPosition", handle_yPosition, yPosition_oid,
                             OID_LENGTH(yPosition_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("xSize", handle_xSize, xSize_oid,
                             OID_LENGTH(xSize_oid), HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("ySize", handle_ySize, ySize_oid,
                             OID_LENGTH(ySize_oid), HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("videoMode", handle_videoMode, videoMode_oid,
                             OID_LENGTH(videoMode_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("alphaLayer", handle_alphaLayer,
                             alphaLayer_oid, OID_LENGTH(alphaLayer_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("activeLayer", handle_activeLayer,
                             activeLayer_oid, OID_LENGTH(activeLayer_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("playBrowser", handle_playBrowser,
                             playBrowser_oid, OID_LENGTH(playBrowser_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("playLayer", handle_playLayer, playLayer_oid,
                             OID_LENGTH(playLayer_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("videoPID", handle_videoPID, videoPID_oid,
                             OID_LENGTH(videoPID_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("audioPID", handle_audioPID, audioPID_oid,
                             OID_LENGTH(audioPID_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("playerBrightness", handle_playerBrightness,
                             playerBrightness_oid,
                             OID_LENGTH(playerBrightness_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("playerContrast", handle_playerContrast,
                             playerContrast_oid,
                             OID_LENGTH(playerContrast_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("playerColor", handle_playerColor,
                             playerColor_oid, OID_LENGTH(playerColor_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("playerTint", handle_playerTint,
                             playerTint_oid, OID_LENGTH(playerTint_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("horizontalSize", handle_horizontalSize,
                             horizontalSize_oid,
                             OID_LENGTH(horizontalSize_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("horizontalShift", handle_horizontalShift,
                             horizontalShift_oid,
                             OID_LENGTH(horizontalShift_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("verticalSize", handle_verticalSize,
                             verticalSize_oid,
                             OID_LENGTH(verticalSize_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("verticalShift", handle_verticalShift,
                             verticalShift_oid,
                             OID_LENGTH(verticalShift_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("networkBurstBufferSize",
                             handle_networkBurstBufferSize,
                             networkBurstBufferSize_oid,
                             OID_LENGTH(networkBurstBufferSize_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("videoJitterSize", handle_videoJitterSize,
                             videoJitterSize_oid,
                             OID_LENGTH(videoJitterSize_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("rtspKeepAlive", handle_rtspKeepAlive,
                             rtspKeepAlive_oid,
                             OID_LENGTH(rtspKeepAlive_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("virtualChannelAlias",
                             handle_virtualChannelAlias,
                             virtualChannelAlias_oid,
                             OID_LENGTH(virtualChannelAlias_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("virtualChannelDisplayPosition",
                             handle_virtualChannelDisplayPosition,
                             virtualChannelDisplayPosition_oid,
                             OID_LENGTH(virtualChannelDisplayPosition_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("virtualChannelEnable",
                             handle_virtualChannelEnable,
                             virtualChannelEnable_oid,
                             OID_LENGTH(virtualChannelEnable_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("virtualChannelMin", handle_virtualChannelMin,
                             virtualChannelMin_oid,
                             OID_LENGTH(virtualChannelMin_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("virtualChannelMax", handle_virtualChannelMax,
                             virtualChannelMax_oid,
                             OID_LENGTH(virtualChannelMax_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("virtualChannelDisplayDuration",
                             handle_virtualChannelDisplayDuration,
                             virtualChannelDisplayDuration_oid,
                             OID_LENGTH(virtualChannelDisplayDuration_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("videoProfileEnable",
                             handle_videoProfileEnable,
                             videoProfileEnable_oid,
                             OID_LENGTH(videoProfileEnable_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("videoProfileRegister",
                             handle_videoProfileRegister,
                             videoProfileRegister_oid,
                             OID_LENGTH(videoProfileRegister_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("closedCaption", handle_closedCaption,
                             closedCaption_oid,
                             OID_LENGTH(closedCaption_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("bootSplashPlayUrl", handle_bootSplashPlayUrl,
                             bootSplashPlayUrl_oid,
                             OID_LENGTH(bootSplashPlayUrl_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("videoSyncMode", handle_videoSyncMode,
                             videoSyncMode_oid,
                             OID_LENGTH(videoSyncMode_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("videoSyncMaster", handle_videoSyncMaster,
                             videoSyncMaster_oid,
                             OID_LENGTH(videoSyncMaster_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("outputSpdifMode", handle_outputSpdifMode,
                             outputSpdifMode_oid,
                             OID_LENGTH(outputSpdifMode_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("Html_EvalJavascript", handle_HtmlEvalJavascript,
                             Html_EvalJavascript_oid,
                             OID_LENGTH(Html_EvalJavascript_oid),
                             HANDLER_CAN_RWRITE));
	netsnmp_register_scalar(netsnmp_create_handler_registration
							("VideoLayerPlayMedia", handle_VideoLayerPlayMedia,
							VideoLayerPlayMedia_oid,
							OID_LENGTH(VideoLayerPlayMedia_oid),
							HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("HtmlLayerPlay", handle_HtmlLayerPlay,
                            HtmlLayerPlay_oid,
                            OID_LENGTH(HtmlLayerPlay_oid),
                            HANDLER_CAN_RWRITE));
	netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("playNext", handle_playNext,
                             playNext_oid, OID_LENGTH(playNext_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("videoRotation", handle_videoRotation,
                             videoRotation_oid, OID_LENGTH(videoRotation_oid),
                             HANDLER_CAN_RWRITE));

	netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("handle_playerColorSpace", handle_playerColorSpace,
                             playerColorSpace_oid, OID_LENGTH(playerColorSpace_oid),
                             HANDLER_CAN_RWRITE));

	netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("playerColorDepth", handle_playerColorDepth,
                             playerColorDepth_oid, OID_LENGTH(playerColorDepth_oid),
                             HANDLER_CAN_RWRITE));

	netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("playerMatrixcoefficients", handle_playerMatrixcoefficients,
                             playerMatrixcoefficients_oid, OID_LENGTH(playerMatrixcoefficients_oid),
                             HANDLER_CAN_RWRITE));
	netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("playSmooth", handle_playSmooth,
                             playSmooth_oid, OID_LENGTH(playSmooth_oid),
                             HANDLER_CAN_RWRITE));
}

int
handle_currentItemBeingPlayed(netsnmp_mib_handler *handler,
                              netsnmp_handler_registration *reginfo,
                              netsnmp_agent_request_info *reqinfo,
                              netsnmp_request_info *requests)
{
    int ret;
    const char *pVal;

    UNUSED(handler);
    UNUSED(reginfo);
    UNUSED(requests);

    switch (reqinfo->mode) {
    case MODE_GET:
        if (DBus_getProperty(SPBus_ControlCenter_UiSrv, "getCurrentPlayItem", NULL,
                             DBUS_TYPE_STRING, &pVal,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: getString='%s'\n", __FUNCTION__, pVal));

        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)pVal, strlen(pVal));
        break;

    default:
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_currentItemBeingPlayed\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_flippingInterval(netsnmp_mib_handler *handler,
                        netsnmp_handler_registration *reginfo,
                        netsnmp_agent_request_info *reqinfo,
                        netsnmp_request_info *requests)
{
    static int flippingIntervalSec = 0;
    int ret;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&flippingIntervalSec, sizeof(flippingIntervalSec));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        ret = *requests->requestvb->val.integer;
        DEBUGMSGTL(("Interface", "%s: flippingIntervalSec='%d'\n", __FUNCTION__, ret));

        if (DBus_setProperty(SPBus_ControlCenter_UiSrv, "setFlippingInterval", NULL,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        flippingIntervalSec = ret;
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_flippingInterval\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_playVirtualChannel(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    int ret, value;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        value = 0;
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value, sizeof(value));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        value = *requests->requestvb->val.integer;
        if (value < 0 || value > 99) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: setInt='%d'\n", __FUNCTION__, value));

        if (DBus_setProperty(SPBus_ControlCenter_UiSrv, "setPlayVirtualChannel", NULL,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_playVirtualChannel\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_playInternalImage(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests)
{
    int ret, temp;
    static int value = 0;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value, sizeof(value));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        temp = *requests->requestvb->val.integer;
        if (temp < 0 || temp > 4) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: setInt='%d'\n", __FUNCTION__, temp));

        if (DBus_setProperty(SPBus_ControlCenter_UiSrv, "setPlayInternalImage", NULL,
                             DBUS_TYPE_INT32, &temp,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        value = temp;
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_playInternalImage\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_playPlaylist(netsnmp_mib_handler *handler,
                    netsnmp_handler_registration *reginfo,
                    netsnmp_agent_request_info *reqinfo,
                    netsnmp_request_info *requests)
{
    int ret, val_len;
    char listName[11];
    char *p;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *) "", 0);
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        val_len = requests->requestvb->val_len;
        if (val_len >= (int)sizeof(listName)) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        strncpy(listName, (char *)requests->requestvb->val.string, val_len);
        listName[val_len] = 0;
        p = listName;

        if (DBus_setProperty(SPBus_ControlCenter_UiSrv, "startPlaylist", NULL,
                             DBUS_TYPE_STRING, &p,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_playPlaylist\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_playMedia(netsnmp_mib_handler *handler,
                 netsnmp_handler_registration *reginfo,
                 netsnmp_agent_request_info *reqinfo,
                 netsnmp_request_info *requests)
{
    int ret, val_len;
    char *pValue;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *) "", 0);
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION: 
        val_len = requests->requestvb->val_len;
        if (val_len > 512) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }
        pValue = netsnmp_strdup_and_null(requests->requestvb->val.string, val_len);
        DEBUGMSGTL(("Interface", "%s: setString='%s'\n", __FUNCTION__, pValue));

        if (DBus_setProperty(SPBus_ControlCenter_UiSrv, "playMedia", NULL,
                             DBUS_TYPE_STRING, &pValue,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        }
        SNMP_FREE(pValue);
        break;
    
    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_playMedia\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_playNextFile(netsnmp_mib_handler *handler,
                    netsnmp_handler_registration *reginfo,
                    netsnmp_agent_request_info *reqinfo,
                    netsnmp_request_info *requests)
{
    int ret, val_len;
    char *pValue;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *) "", 0);
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        val_len = requests->requestvb->val_len;
        if (val_len > 512) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }
        pValue = netsnmp_strdup_and_null(requests->requestvb->val.string, val_len);
        DEBUGMSGTL(("Interface", "%s: setString='%s'\n", __FUNCTION__, pValue));

        if (DBus_setProperty(SPBus_ControlCenter_UiSrv, "playNextFile", NULL,
                             DBUS_TYPE_STRING, &pValue,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        }
        SNMP_FREE(pValue);
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_playNextFile\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_playerState(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    int ret, value;
    UNUSED(handler);
    UNUSED(reginfo);
    UNUSED(requests);

    switch (reqinfo->mode) {
    case MODE_GET:
        if (DBus_getProperty(SPBus_ControlCenter_UiSrv, "getPlayState", NULL,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            DEBUGMSGTL(("Interface", "%s: ret='%d'\n", __FUNCTION__, ret));
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: getInt='%d'\n", __FUNCTION__, value));

        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value, sizeof(value));
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_playerState\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_playMode(netsnmp_mib_handler *handler,
                netsnmp_handler_registration *reginfo,
                netsnmp_agent_request_info *reqinfo,
                netsnmp_request_info *requests)
{
    int ret, mode = 0;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        if (DBus_getProperty(SPBus_ControlCenter_UiSrv, "getPlayMode", NULL,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_INT32, &mode,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: getInt='%d'\n", __FUNCTION__, mode));

        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&mode, sizeof(mode));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        mode= *requests->requestvb->val.integer;
#if 0
        if (mode < 0 || mode > 8) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }
#endif

        if (DBus_setProperty(SPBus_ControlCenter_UiSrv, "setPlayMode", NULL,
                              DBUS_TYPE_INT32, &mode,
                              DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_playMode\n", reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_virtualChannelID(netsnmp_mib_handler *handler,
                        netsnmp_handler_registration *reginfo,
                        netsnmp_agent_request_info *reqinfo,
                        netsnmp_request_info *requests)
{
    int ret, value;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        if (DBus_getProperty(SPBus_ControlCenter_UiSrv, "getVirtualChannelId", NULL,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: getInt='%d'\n", __FUNCTION__, value));

        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value, sizeof(value));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        value = *requests->requestvb->val.integer;
        if (value < 1 || value > 99) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: setInt='%d'\n", __FUNCTION__, value));

        if (DBus_setProperty(SPBus_ControlCenter_UiSrv, "setVirtualChannelId", NULL,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_virtualChannelID\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_virtualChannelMedia(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests)
{
    int ret;
    unsigned int val_len;
    char szVaule[65];
    const char *pValue;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        if (DBus_getProperty(SPBus_ControlCenter_UiSrv, "getVirChMedia", NULL,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_STRING, &pValue,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }
        val_len = strlen(pValue);
        if (val_len + 1 > sizeof(szVaule)) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }
        strncpy(szVaule, pValue, val_len);
        szVaule[val_len] = 0;
        pValue = szVaule;
        DEBUGMSGTL(("Interface", "%s: getString='%s'\n", __FUNCTION__, pValue));

        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)pValue, val_len);
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        pValue = (const char *)requests->requestvb->val.string;
        val_len = requests->requestvb->val_len;
        if (val_len + 1 > sizeof(szVaule)) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }
        strncpy(szVaule, pValue, val_len);
        szVaule[val_len] = 0;
        pValue = szVaule;
        DEBUGMSGTL(("Interface", "%s: setString='%s'\n", __FUNCTION__, pValue));

        if (DBus_setProperty(SPBus_ControlCenter_UiSrv, "setVirChMedia", NULL,
                             DBUS_TYPE_STRING, &pValue,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_virtualChannelMedia\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_videoType(netsnmp_mib_handler *handler,
                 netsnmp_handler_registration *reginfo,
                 netsnmp_agent_request_info *reqinfo,
                 netsnmp_request_info *requests)
{
    int             ret;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
#if 0
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *) xxx, sizeof(xxx));
#endif
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        if (0) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
        break;

    case MODE_SET_COMMIT:
        if (0) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_videoType\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_audioType(netsnmp_mib_handler *handler,
                 netsnmp_handler_registration *reginfo,
                 netsnmp_agent_request_info *reqinfo,
                 netsnmp_request_info *requests)
{
    int             ret;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
#if 0
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *) xxx, sizeof(xxx));
#endif
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        if (0) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
        break;

    case MODE_SET_COMMIT:
        if (0) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_audioType\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_audioSampFreq(netsnmp_mib_handler *handler,
                     netsnmp_handler_registration *reginfo,
                     netsnmp_agent_request_info *reqinfo,
                     netsnmp_request_info *requests)
{
    int             ret;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
#if 0
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *) xxx, sizeof(xxx));
#endif
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        if (0) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
        break;

    case MODE_SET_COMMIT:
        if (0) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_audioSampFreq\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_defaultStartupItem(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    static char defaultStartupItem[384 + 1];
    unsigned int val_len;
    const char *pValue;
    int ret;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        if (DBus_getProperty(SPBus_ControlCenter_UiSrv, "getDefaultStartupItem", NULL,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_STRING, &pValue,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: getString='%s'\n", __FUNCTION__, pValue));

        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)pValue, strlen(pValue));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        pValue = (const char *)requests->requestvb->val.string;
        val_len = requests->requestvb->val_len;
        if (val_len + 1 > sizeof(defaultStartupItem)) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        strncpy(defaultStartupItem, pValue, val_len);
        defaultStartupItem[val_len] = 0;
        pValue = defaultStartupItem;

        DEBUGMSGTL(("Interface", "%s: setString='%s'\n", __FUNCTION__, pValue));

        if (DBus_setProperty(SPBus_ControlCenter_UiSrv, "setDefaultStartupItem", NULL,
                              DBUS_TYPE_STRING, &pValue,
                              DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }

        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_defaultStartupItem\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_currentFrameCount(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests)
{
    UNUSED(handler);
    UNUSED(reginfo);
    UNUSED(requests);

    switch (reqinfo->mode) {
    case MODE_GET:
#if 0
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *) xxx, sizeof(xxx));
#endif
        break;


    default:
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_currentFrameCount\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_defaultIdlePlaylist(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests)
{
    int ret;
    char *pValue;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        if (DBus_getProperty(SPBus_ControlCenter_UiSrv, "getDefaultIdlePlaylist", NULL,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_STRING, &pValue,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: getString='%s'\n", __FUNCTION__, pValue));

        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)pValue, strlen(pValue));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        if (requests->requestvb->val_len > 256) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }
        pValue = netsnmp_strdup_and_null(requests->requestvb->val.string,
                                         requests->requestvb->val_len);
        DEBUGMSGTL(("Interface", "%s: setString='%s'\n", __FUNCTION__, pValue));

        if (DBus_setProperty(SPBus_ControlCenter_UiSrv, "setDefaultIdlePlaylist", NULL,
                              DBUS_TYPE_STRING, &pValue,
                              DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        }
        SNMP_FREE(pValue);
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_defaultIdlePlaylist\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_idleDetect(netsnmp_mib_handler *handler,
                  netsnmp_handler_registration *reginfo,
                  netsnmp_agent_request_info *reqinfo,
                  netsnmp_request_info *requests)
{
    int ret, idleDetectSec;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        if (DBus_getProperty(SPBus_ControlCenter_UiSrv, "getIdleDetect", NULL,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_INT32, &idleDetectSec,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: getInt='%d'\n", __FUNCTION__, idleDetectSec));

        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&idleDetectSec, sizeof(idleDetectSec));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        idleDetectSec = *requests->requestvb->val.integer;
        if (idleDetectSec < 0 || idleDetectSec > 32768) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: idleDetectSec='%d'\n", __FUNCTION__, idleDetectSec));

        if (DBus_setProperty(SPBus_ControlCenter_UiSrv, "setIdleDetect", NULL,
                             DBUS_TYPE_INT32, &idleDetectSec,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_idleDetect\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_playerVolume(netsnmp_mib_handler *handler,
                    netsnmp_handler_registration *reginfo,
                    netsnmp_agent_request_info *reqinfo,
                    netsnmp_request_info *requests)
{
    int ret, value;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        if (DBus_getProperty(SPBus_ControlCenter_UiSrv, "getPlayVolume", NULL,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: getInt='%d'\n", __FUNCTION__, value));

        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value, sizeof(value));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        value = *requests->requestvb->val.integer;
        if (value < 0 || value > MAX_PLAYER_VOLUME) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }
        if (DBus_setProperty(SPBus_ControlCenter_UiSrv, "setPlayVolume", NULL,
                              DBUS_TYPE_INT32, &value,
                              DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_playerVolume\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_playerMute(netsnmp_mib_handler *handler,
                  netsnmp_handler_registration *reginfo,
                  netsnmp_agent_request_info *reqinfo,
                  netsnmp_request_info *requests)
{
    int ret, value;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        if (DBus_getProperty(SPBus_ControlCenter_UiSrv, "getPlayerMute", NULL,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }

        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value, sizeof(value));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        value = *requests->requestvb->val.integer;
        if (value != 0 && value != 1) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: getInt='%d'\n", __FUNCTION__, value));

        if (DBus_setProperty(SPBus_ControlCenter_UiSrv, "setPlayerMute", NULL,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_playerMute\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_speedControl(netsnmp_mib_handler *handler,
                    netsnmp_handler_registration *reginfo,
                    netsnmp_agent_request_info *reqinfo,
                    netsnmp_request_info *requests)
{
    int ret, mode = 0;
    int value = 0;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
		if (DBus_getProperty(SPBus_MPlayer, "getPlaySpeed", NULL,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_INT32, &mode,
                             DBUS_TYPE_INVALID) != 0) {
           netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: getInt='%d'\n", __FUNCTION__, mode));

        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&mode, sizeof(mode));
        break;
    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        value = *requests->requestvb->val.integer;
        if (value < 5 || value > 250) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: getInt='%d'\n", __FUNCTION__, value));
     //   if (DBus_setProperty(SPBus_MPlayer, "setPlaySpeedCtrlAsync", NULL,
     	if (DBus_setProperty(SPBus_MPlayer, "setPlaySpeed", NULL,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_speedControl\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_videoSysType(netsnmp_mib_handler *handler,
                    netsnmp_handler_registration *reginfo,
                    netsnmp_agent_request_info *reqinfo,
                    netsnmp_request_info *requests)
{
    int             ret;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
#if 0
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *) xxx, sizeof(xxx));
#endif
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        if (0) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
        break;

    case MODE_SET_COMMIT:
        if (0) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_videoSysType\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_coordinateMode(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests)
{
    int ret, value;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        if (DBus_getProperty(SPBus_ControlCenter_UiSrv, "getCoordinateMode", NULL,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }

        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value, sizeof(value));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        value = *requests->requestvb->val.integer;
        if (value != 0 && value != 1) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: coordinateMode='%s'\n", __FUNCTION__,
                    value ? "absolute" : "relative"));

        if (DBus_setProperty(SPBus_ControlCenter_UiSrv, "setCoordinateMode", NULL,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_coordinateMode\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_xPosition(netsnmp_mib_handler *handler,
                 netsnmp_handler_registration *reginfo,
                 netsnmp_agent_request_info *reqinfo,
                 netsnmp_request_info *requests)
{
    int ret, value;
    static int iPos = 0;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&iPos,
                                 sizeof(iPos));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        value = *requests->requestvb->val.integer;
        if (value < -4096 || value > 4096) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            return SNMP_ERR_GENERR;
        }
        DEBUGMSGTL(("Interface", "%s: iPosX='%d'\n", __FUNCTION__, value));

        ret = ControlCenter::AMedia_POSTION_X;
        if (DBus_setProperty(SPBus_ControlCenter_UiSrv, "setVideoPosition", NULL,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        iPos = value;
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_xPosition\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_yPosition(netsnmp_mib_handler *handler,
                 netsnmp_handler_registration *reginfo,
                 netsnmp_agent_request_info *reqinfo,
                 netsnmp_request_info *requests)
{
    int ret, value;
    static int iPos = 0;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&iPos,
                                 sizeof(iPos));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        value = *requests->requestvb->val.integer;
        if (value < -4096 || value > 4096) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            return SNMP_ERR_GENERR;
        }

        DEBUGMSGTL(("Interface", "%s: iPosY='%d'\n", __FUNCTION__, value));

        ret = ControlCenter::AMedia_POSTION_Y;
        if (DBus_setProperty(SPBus_ControlCenter_UiSrv, "setVideoPosition", NULL,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        iPos = value;
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_yPosition\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_xSize(netsnmp_mib_handler *handler,
             netsnmp_handler_registration *reginfo,
             netsnmp_agent_request_info *reqinfo,
             netsnmp_request_info *requests)
{
    int ret, value;
    static int iSize = 0;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&iSize,
                                 sizeof(iSize));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        value = *requests->requestvb->val.integer;
        if (value < -4096 || value > 4096) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            return SNMP_ERR_GENERR;
        }
        DEBUGMSGTL(("Interface", "%s: iSizeX='%d'\n", __FUNCTION__, value));

        ret = ControlCenter::AMedia_POSTION_XSIZE;
        if (DBus_setProperty(SPBus_ControlCenter_UiSrv, "setVideoPosition", NULL,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        iSize = value;
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_xSize\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_ySize(netsnmp_mib_handler *handler,
             netsnmp_handler_registration *reginfo,
             netsnmp_agent_request_info *reqinfo,
             netsnmp_request_info *requests)
{
    int ret, value;
    static int iSize = 0;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&iSize,
                                 sizeof(iSize));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        value = *requests->requestvb->val.integer;
        if (value < -4096 || value > 4096) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            return SNMP_ERR_GENERR;
        }
        DEBUGMSGTL(("Interface", "%s: iSizeY='%d'\n", __FUNCTION__, iSize));

        ret = ControlCenter::AMedia_POSTION_YSIZE;
        if (DBus_setProperty(SPBus_ControlCenter_UiSrv, "setVideoPosition", NULL,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        iSize = value;
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_ySize\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_videoMode(netsnmp_mib_handler *handler,
                 netsnmp_handler_registration *reginfo,
                 netsnmp_agent_request_info *reqinfo,
                 netsnmp_request_info *requests)
{
    int ret, value, flag;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        if (DBus_getProperty(SPBus_MPlayer, "getVideoDispAspectRatio", NULL,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: getInt='%d'\n", __FUNCTION__, value));
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value, sizeof(value));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        value = *requests->requestvb->val.integer;
#if 0
        if (value < 0 || value > 2) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }
#endif
        flag = 1;
        if (DBus_setProperty(SPBus_MPlayer, "setVideoDispAspectRatio", NULL,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_UINT32, &flag,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_videoMode\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_alphaLayer(netsnmp_mib_handler *handler,
                  netsnmp_handler_registration *reginfo,
                  netsnmp_agent_request_info *reqinfo,
                  netsnmp_request_info *requests)
{
    int             ret;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
#if 0
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *) xxx, sizeof(xxx));
#endif
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        if (0) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
        break;

    case MODE_SET_COMMIT:
        if (0) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_alphaLayer\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_activeLayer(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    int             ret;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
#if 0
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *) xxx, sizeof(xxx));
#endif
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        if (0) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
        break;

    case MODE_SET_COMMIT:
        if (0) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_activeLayer\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_playBrowser(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    int ret;
    char *pValue;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *) "", 0);
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        pValue = netsnmp_strdup_and_null(requests->requestvb->val.string,
                                         requests->requestvb->val_len);
        DEBUGMSGTL(("Interface", "%s: setString='%s'\n", __FUNCTION__, pValue));

        if (DBus_setProperty(SPBus_ControlCenter_UiSrv, "playBrowser", NULL,
                             DBUS_TYPE_STRING, &pValue,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        }
        SNMP_FREE(pValue);
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_playBrowser\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_playLayer(netsnmp_mib_handler *handler,
                 netsnmp_handler_registration *reginfo,
                 netsnmp_agent_request_info *reqinfo,
                 netsnmp_request_info *requests)
{
    int             ret;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
#if 0
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *) xxx, sizeof(xxx));
#endif
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        if (0) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
        break;

    case MODE_SET_COMMIT:
        if (0) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_playLayer\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_videoPID(netsnmp_mib_handler *handler,
                netsnmp_handler_registration *reginfo,
                netsnmp_agent_request_info *reqinfo,
                netsnmp_request_info *requests)
{
    int             ret;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
#if 0
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *) xxx, sizeof(xxx));
#endif
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        if (0) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
        break;

    case MODE_SET_COMMIT:
        if (0) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_videoPID\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_audioPID(netsnmp_mib_handler *handler,
                netsnmp_handler_registration *reginfo,
                netsnmp_agent_request_info *reqinfo,
                netsnmp_request_info *requests)
{
    int             ret;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
#if 0
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *) xxx, sizeof(xxx));
#endif
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        if (0) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
        break;

    case MODE_SET_COMMIT:
        if (0) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_audioPID\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_playerBrightness(netsnmp_mib_handler *handler,
                        netsnmp_handler_registration *reginfo,
                        netsnmp_agent_request_info *reqinfo,
                        netsnmp_request_info *requests)
{
    int ret, value, bSaveCfg;
    SPArgs args;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        args.eType = SPValue_Integer;
        args.integer = MediaPlayer::DispPARAM_Brightness;
        if (DBus_getProperty(SPBus_MPlayer, "getDisplayParam", &args,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }

        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value, sizeof(value));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        value = *requests->requestvb->val.integer;
        if (value < 0 || value > 100) {
            netsnmp_set_request_error (reqinfo, requests, SNMP_ERR_WRONGVALUE);
            return SNMP_ERR_GENERR;
        }
        args.integer = MediaPlayer::DispPARAM_Brightness;
        bSaveCfg = 1;
        DEBUGMSGTL(("Interface", "%s: DispPARAM='%s' bSaveCfg='%d'\n", __FUNCTION__,
                    "Brightness", bSaveCfg));

        if (DBus_setProperty(SPBus_ControlCenter_UiSrv, "setDisplayParam", NULL,
                             DBUS_TYPE_INT32, &args.integer,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INT32, &bSaveCfg,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_playerBrightness\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_playerContrast(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests)
{
    int ret, value, bSaveCfg;
    SPArgs args;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        args.eType = SPValue_Integer;
        args.integer = MediaPlayer::DispPARAM_Contrast;
        if (DBus_getProperty(SPBus_MPlayer, "getDisplayParam", &args,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }

        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value, sizeof(value));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        value = *requests->requestvb->val.integer;
        if (value < 0 || value > 100) {
            netsnmp_set_request_error (reqinfo, requests, SNMP_ERR_WRONGVALUE);
            return SNMP_ERR_GENERR;
        }
        args.integer = MediaPlayer::DispPARAM_Contrast;
        bSaveCfg = 1;
        DEBUGMSGTL(("Interface", "%s: DispPARAM='%s' bSaveCfg='%d' value='%d'\n", __FUNCTION__,
                    "Brightness", bSaveCfg, value));

        if (DBus_setProperty(SPBus_ControlCenter_UiSrv, "setDisplayParam", NULL,
                             DBUS_TYPE_INT32, &args.integer,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INT32, &bSaveCfg,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_playerContrast\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_playerColor(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    int ret, value, bSaveCfg;
    SPArgs args;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        args.eType = SPValue_Integer;
        args.integer = MediaPlayer::DispPARAM_Saturation;
        if (DBus_getProperty(SPBus_MPlayer, "getDisplayParam", &args,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }

        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value, sizeof(value));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        value = *requests->requestvb->val.integer;
        if (value < 0 || value > 100) {
            netsnmp_set_request_error (reqinfo, requests, SNMP_ERR_WRONGVALUE);
            return SNMP_ERR_GENERR;
        }
        args.integer = MediaPlayer::DispPARAM_Saturation;
        bSaveCfg = 1;
        DEBUGMSGTL(("Interface", "%s: DispPARAM='%s' bSaveCfg='%d' value='%d'\n", __FUNCTION__,
                    "Saturation", bSaveCfg, value));

        if (DBus_setProperty(SPBus_ControlCenter_UiSrv, "setDisplayParam", NULL,
                             DBUS_TYPE_INT32, &args.integer,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INT32, &bSaveCfg,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_playerColor\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_playerColorSpace(netsnmp_mib_handler *handler,
                        netsnmp_handler_registration *reginfo,
                        netsnmp_agent_request_info *reqinfo,
                        netsnmp_request_info *requests)
{
    int ret, value, bSaveCfg;
    SPArgs args;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        args.eType = SPValue_Integer;
        args.integer = MediaPlayer::DispPARAM_ColorSpace;
        if (DBus_getProperty(SPBus_MPlayer, "getDisplayParam", &args,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }

        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value, sizeof(value));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        value = *requests->requestvb->val.integer;
        if (value < 0 || value > 4) {
            netsnmp_set_request_error (reqinfo, requests, SNMP_ERR_WRONGVALUE);
            return SNMP_ERR_GENERR;
        }
        args.integer = MediaPlayer::DispPARAM_ColorSpace;
        bSaveCfg = 1;
        DEBUGMSGTL(("Interface", "%s: DispPARAM='%s' bSaveCfg='%d'\n", __FUNCTION__,
                    "Brightness", bSaveCfg));

        if (DBus_setProperty(SPBus_MPlayer, "setDisplayParam", NULL,
                             DBUS_TYPE_INT32, &args.integer,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INT32, &bSaveCfg,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_playerBrightness\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}



int
handle_playerColorDepth(netsnmp_mib_handler *handler,
                        netsnmp_handler_registration *reginfo,
                        netsnmp_agent_request_info *reqinfo,
                        netsnmp_request_info *requests)
{
    int ret, value, bSaveCfg;
    SPArgs args;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        args.eType = SPValue_Integer;
        args.integer = MediaPlayer::DispPARAM_ColorDepth;
        if (DBus_getProperty(SPBus_MPlayer, "getDisplayParam", &args,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }

        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value, sizeof(value));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        value = *requests->requestvb->val.integer;
        if (value < 0 || value > 3) {
            netsnmp_set_request_error (reqinfo, requests, SNMP_ERR_WRONGVALUE);
            return SNMP_ERR_GENERR;
        }
        args.integer = MediaPlayer::DispPARAM_ColorDepth;
        bSaveCfg = 1;
        DEBUGMSGTL(("Interface", "%s: DispPARAM='%s' bSaveCfg='%d'\n", __FUNCTION__,
                    "Brightness", bSaveCfg));

        if (DBus_setProperty(SPBus_MPlayer, "setDisplayParam", NULL,
                             DBUS_TYPE_INT32, &args.integer,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INT32, &bSaveCfg,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_playerBrightness\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
handle_playerMatrixcoefficients(netsnmp_mib_handler *handler,
                        netsnmp_handler_registration *reginfo,
                        netsnmp_agent_request_info *reqinfo,
                        netsnmp_request_info *requests)
{
    int ret, value, bSaveCfg;
    SPArgs args;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        args.eType = SPValue_Integer;
        args.integer = MediaPlayer::DispPARAM_matrixcoefficients;
        if (DBus_getProperty(SPBus_MPlayer, "getDisplayParam", &args,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }

        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value, sizeof(value));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        value = *requests->requestvb->val.integer;
        if (value < 0 || value > 5) {
            netsnmp_set_request_error (reqinfo, requests, SNMP_ERR_WRONGVALUE);
            return SNMP_ERR_GENERR;
        }
        args.integer = MediaPlayer::DispPARAM_matrixcoefficients;
        bSaveCfg = 1;
        DEBUGMSGTL(("Interface", "%s: DispPARAM='%s' bSaveCfg='%d'\n", __FUNCTION__,
                    "Brightness", bSaveCfg));

        if (DBus_setProperty(SPBus_MPlayer, "setDisplayParam", NULL,
                             DBUS_TYPE_INT32, &args.integer,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INT32, &bSaveCfg,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_playerBrightness\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
handle_playerTint(netsnmp_mib_handler *handler,
                  netsnmp_handler_registration *reginfo,
                  netsnmp_agent_request_info *reqinfo,
                  netsnmp_request_info *requests)
{
    int ret, value, bSaveCfg;
    SPArgs args;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        args.eType = SPValue_Integer;
        args.integer = MediaPlayer::DispPARAM_Hue;
        if (DBus_getProperty(SPBus_MPlayer, "getDisplayParam", &args,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }

        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value, sizeof(value));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        value = *requests->requestvb->val.integer;
        if (value < 0 || value > 100) {
            netsnmp_set_request_error (reqinfo, requests, SNMP_ERR_WRONGVALUE);
            return SNMP_ERR_GENERR;
        }
        args.integer = MediaPlayer::DispPARAM_Hue;
        bSaveCfg = 1;
        DEBUGMSGTL(("Interface", "%s: DispPARAM='%s' bSaveCfg='%d' value='%d'\n", __FUNCTION__,
                    "Hue", bSaveCfg, value));

        if (DBus_setProperty(SPBus_ControlCenter_UiSrv, "setDisplayParam", NULL,
                             DBUS_TYPE_INT32, &args.integer,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INT32, &bSaveCfg,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_playerTint\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_horizontalSize(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests)
{
    int ret, value;
    SPArgs args;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        args.eType = SPValue_Integer;
        args.integer = ControlCenter::AMedia_POSTION_ShiftXSIZE;
        if (DBus_getProperty(SPBus_ControlCenter_UiSrv, "getShitfPosition", &args,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: getInt='%d'\n", __FUNCTION__, value));

        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value, sizeof(value));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        value = *requests->requestvb->val.integer;
        if (value < 0 || value > 100) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }
        args.eType = (typeof(args.eType))(ControlCenter::AMedia_POSTION_ShiftXSIZE);
        DEBUGMSGTL(("Interface", "%s: ShiftXSIZE='%d'\n", __FUNCTION__, ret));

        if (DBus_setProperty(SPBus_ControlCenter_UiSrv, "setShitfPosition", NULL,
                             DBUS_TYPE_INT32, &args.eType,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_horizontalSize\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_horizontalShift(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info *reqinfo,
                       netsnmp_request_info *requests)
{
    int ret, value;
    SPArgs args;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        args.eType = SPValue_Integer;
        args.integer = ControlCenter::AMedia_POSTION_ShiftX;
        if (DBus_getProperty(SPBus_ControlCenter_UiSrv, "getShitfPosition", &args,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: getInt='%d'\n", __FUNCTION__, value));

        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value, sizeof(value));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        value = *requests->requestvb->val.integer;
        if (value < 0 || value > 100) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            return SNMP_ERR_GENERR;
        }
        args.integer = ControlCenter::AMedia_POSTION_ShiftX;
        DEBUGMSGTL(("Interface", "%s: ShiftX='%d'\n", __FUNCTION__, value));

        if (DBus_setProperty(SPBus_ControlCenter_UiSrv, "setShitfPosition", NULL,
                             DBUS_TYPE_INT32, &args.integer,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_horizontalShift\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_verticalSize(netsnmp_mib_handler *handler,
                    netsnmp_handler_registration *reginfo,
                    netsnmp_agent_request_info *reqinfo,
                    netsnmp_request_info *requests)
{
    int ret, value;
    SPArgs args;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        args.eType = SPValue_Integer;
        args.integer = ControlCenter::AMedia_POSTION_ShiftYSIZE;
        if (DBus_getProperty(SPBus_ControlCenter_UiSrv, "getShitfPosition", &args,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: getInt='%d'\n", __FUNCTION__, value));

        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value, sizeof(value));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        value = *requests->requestvb->val.integer;
        if (value < 0 || value > 100) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }
        args.integer = ControlCenter::AMedia_POSTION_ShiftYSIZE;
        DEBUGMSGTL(("Interface", "%s: ShiftYSIZE='%d'\n", __FUNCTION__, value));

        if (DBus_setProperty(SPBus_ControlCenter_UiSrv, "setShitfPosition", NULL,
                             DBUS_TYPE_INT32, &args.integer,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_verticalSize\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_verticalShift(netsnmp_mib_handler *handler,
                     netsnmp_handler_registration *reginfo,
                     netsnmp_agent_request_info *reqinfo,
                     netsnmp_request_info *requests)
{
    int ret, value;
    SPArgs args;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        args.eType = SPValue_Integer;
        args.integer = ControlCenter::AMedia_POSTION_ShiftY;
        if (DBus_getProperty(SPBus_ControlCenter_UiSrv, "getShitfPosition", &args,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: getInt='%d'\n", __FUNCTION__, value));

        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value, sizeof(value));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        value = *requests->requestvb->val.integer;
        if (value < 0 || value > 100) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }
        args.integer = ControlCenter::AMedia_POSTION_ShiftY;
        DEBUGMSGTL(("Interface", "%s: ShitfY='%d'\n", __FUNCTION__, value));

        if (DBus_setProperty(SPBus_ControlCenter_UiSrv, "setShitfPosition", NULL,
                             DBUS_TYPE_INT32, &args.integer,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_verticalShift\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_networkBurstBufferSize(netsnmp_mib_handler *handler,
                              netsnmp_handler_registration *reginfo,
                              netsnmp_agent_request_info *reqinfo,
                              netsnmp_request_info *requests)
{
    int             ret;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
#if 0
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *) xxx, sizeof(xxx));
#endif
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        if (0) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
        break;

    case MODE_SET_COMMIT:
        if (0) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_networkBurstBufferSize\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_videoJitterSize(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info *reqinfo,
                       netsnmp_request_info *requests)
{
    int             ret;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
#if 0
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *) xxx, sizeof(xxx));
#endif
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        if (0) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
        break;

    case MODE_SET_COMMIT:
        if (0) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_videoJitterSize\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_rtspKeepAlive(netsnmp_mib_handler *handler,
                     netsnmp_handler_registration *reginfo,
                     netsnmp_agent_request_info *reqinfo,
                     netsnmp_request_info *requests)
{
    int             ret;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
#if 0
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *) xxx, sizeof(xxx));
#endif
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        if (0) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
        break;

    case MODE_SET_COMMIT:
        if (0) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_rtspKeepAlive\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_virtualChannelAlias(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests)
{
    int ret;
    unsigned int val_len;
    char szVaule[9];
    const char *pValue;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        if (DBus_getProperty(SPBus_ControlCenter_UiSrv, "getVirtualChannelAlias", NULL,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_STRING, &pValue,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: getString='%s'\n", __FUNCTION__, pValue));

        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)pValue, strlen(pValue));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        val_len = requests->requestvb->val_len;
        if (val_len + 1 > sizeof(szVaule) || val_len < 1) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }
        pValue = (const char *)requests->requestvb->val.string;
        strncpy(szVaule, pValue, val_len);
        szVaule[val_len] = 0;
        pValue = szVaule;
        DEBUGMSGTL(("Interface", "%s: setString='%s'\n", __FUNCTION__, pValue));

        if (DBus_setProperty(SPBus_ControlCenter_UiSrv, "setVirtualChannelAlias", NULL,
                              DBUS_TYPE_STRING, &pValue,
                              DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_virtualChannelAlias\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_virtualChannelDisplayPosition(netsnmp_mib_handler *handler,
                                     netsnmp_handler_registration *reginfo,
                                     netsnmp_agent_request_info *reqinfo,
                                     netsnmp_request_info *requests)
{
    int ret, value;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        if (DBus_getProperty(SPBus_ControlCenter_UiSrv, "getVirChLabelDispPos", NULL,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }
        if (value < 0 || value > 3) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: getInt='%d'\n", __FUNCTION__, value));

        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value, sizeof(value));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        value = *requests->requestvb->val.integer;
        if (value < 1 || value > 3) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: setInt='%d'\n", __FUNCTION__, value));

        if (DBus_setProperty(SPBus_ControlCenter_UiSrv, "setVirChLabelDispPos", NULL,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_virtualChannelDisplayPosition\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_virtualChannelEnable(netsnmp_mib_handler *handler,
                            netsnmp_handler_registration *reginfo,
                            netsnmp_agent_request_info *reqinfo,
                            netsnmp_request_info *requests)
{
    int ret, value;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        if (DBus_getProperty(SPBus_ControlCenter_UiSrv, "getVirChEnable", NULL,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            DEBUGMSGTL(("Interface", "%s: ret='%d'\n", __FUNCTION__, ret));
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }
        if (value != 0 && value != 1) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: getInt='%d'\n", __FUNCTION__, value));

        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value, sizeof(value));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        value = *requests->requestvb->val.integer;
        if (value != 0 && value != 1) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: setInt='%d'\n", __FUNCTION__, value));

        if (DBus_setProperty(SPBus_ControlCenter_UiSrv, "setVirChEnable", NULL,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_virtualChannelEnable\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_virtualChannelMin(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests)
{
    int ret, value;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        if (DBus_getProperty(SPBus_ControlCenter_UiSrv, "getVirChMin", NULL,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            DEBUGMSGTL(("Interface", "%s: ret='%d'\n", __FUNCTION__, ret));
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: getInt='%d'\n", __FUNCTION__, value));
#if 0
        if (value < 0 || value > 98) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }
#endif
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value, sizeof(value));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        value = *requests->requestvb->val.integer;
        if (value < 0 || value > 98) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: setInt='%d'\n", __FUNCTION__, value));

        if (DBus_setProperty(SPBus_ControlCenter_UiSrv, "setVirChMin", NULL,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_virtualChannelMin\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_virtualChannelMax(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests)
{
    int ret, value;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        if (DBus_getProperty(SPBus_ControlCenter_UiSrv, "getVirChMax", NULL,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            DEBUGMSGTL(("Interface", "%s: ret='%d'\n", __FUNCTION__, ret));
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: getInt='%d'\n", __FUNCTION__, value));
#if 0
        if (value < 0 || value > 99) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }
#endif
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value, sizeof(value));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        value = *requests->requestvb->val.integer;
        if (value < 1 || value > 99) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: setInt='%d'\n", __FUNCTION__, value));

        if (DBus_setProperty(SPBus_ControlCenter_UiSrv, "setVirChMax", NULL,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_virtualChannelMax\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_virtualChannelDisplayDuration(netsnmp_mib_handler *handler,
                                     netsnmp_handler_registration *reginfo,
                                     netsnmp_agent_request_info *reqinfo,
                                     netsnmp_request_info *requests)
{
    int ret, value;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        if (DBus_getProperty(SPBus_ControlCenter_UiSrv, "getVirChDispDuration", NULL,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            DEBUGMSGTL(("Interface", "%s: ret='%d'\n", __FUNCTION__, ret));
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: getInt='%d'\n", __FUNCTION__, value));

        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value, sizeof(value));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        value = *requests->requestvb->val.integer;
        if (value < 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: setInt='%d'\n", __FUNCTION__, value));

        if (DBus_setProperty(SPBus_ControlCenter_UiSrv, "setVirChDispDuration", NULL,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_virtualChannelDisplayDuration\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_videoProfileEnable(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    int ret;
    static int bEnable = 0;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&bEnable, sizeof(bEnable));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        ret = *requests->requestvb->val.integer;
        if (ret != 0 && ret != 1) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            return SNMP_ERR_GENERR;
        }
        bEnable = ret;
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_videoProfileEnable\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_videoProfileRegister(netsnmp_mib_handler *handler,
                            netsnmp_handler_registration *reginfo,
                            netsnmp_agent_request_info *reqinfo,
                            netsnmp_request_info *requests)
{
    int ret;
    static int iProbeFileType = 0;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&iProbeFileType, sizeof(iProbeFileType));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        ret = *requests->requestvb->val.integer;
        if (ret != 0 && ret != 1) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            return SNMP_ERR_GENERR;
        }
        iProbeFileType = ret;
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_videoProfileRegister\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_closedCaption(netsnmp_mib_handler *handler,
                    netsnmp_handler_registration *reginfo,
                    netsnmp_agent_request_info *reqinfo,
                    netsnmp_request_info *requests)
{
    int             ret,value;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        if (DBus_getProperty(SPBus_MPlayer, "getShowClosedCaption", NULL,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            DEBUGMSGTL(("Interface", "%s: ret='%d'\n", __FUNCTION__, ret));
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: getInt='%d'\n", __FUNCTION__, value));

        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value, sizeof(value));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        
        value = *requests->requestvb->val.integer;
        if (value < 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: setInt='%d'\n", __FUNCTION__, value));
        if (DBus_setProperty(SPBus_MPlayer, "setShowClosedCaption", NULL,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        break;

    case MODE_SET_COMMIT:
         if (0) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_closeCaption\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_bootSplashPlayUrl(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests)
{
    int ret, val_len;
    char *pValue;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        if (DBus_getProperty(SPBus_ControlCenter_UiSrv, "getBootSplashPlayUrl", NULL,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_STRING, &pValue,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: getString='%s'\n", __FUNCTION__, pValue));

        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)pValue, strlen(pValue));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION: 
        val_len = requests->requestvb->val_len;
        if (val_len > 512) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }
        pValue = netsnmp_strdup_and_null(requests->requestvb->val.string, val_len);
        DEBUGMSGTL(("Interface", "%s: setString='%s'\n", __FUNCTION__, pValue));

        if (DBus_setProperty(SPBus_ControlCenter_UiSrv, "setBootSplashPlayUrl", NULL,
                             DBUS_TYPE_STRING, &pValue,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        }
        SNMP_FREE(pValue);
        break;
    
    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_playMedia\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_videoSyncMode(netsnmp_mib_handler *handler,
                     netsnmp_handler_registration *reginfo,
                     netsnmp_agent_request_info *reqinfo,
                     netsnmp_request_info *requests)
{
    int ret, value;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        if (DBus_getProperty(SPBus_MPlayer, "getVideoSyncMode", NULL,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: getInt='%d'\n", __FUNCTION__, value));

        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value, sizeof(value));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION: 
        value = *requests->requestvb->val.integer;
        DEBUGMSGTL(("Interface", "%s: setInt='%d'\n", __FUNCTION__, value));
        if (value < 0 || value > 2) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }

        if (DBus_setProperty(SPBus_MPlayer, "setVideoSyncMode", NULL,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        }
        break;
    
    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_videoSyncMode\n", reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_videoSyncMaster(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info *reqinfo,
                       netsnmp_request_info *requests)
{
    int ret, val_len;
    const char *pValue;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        if (DBus_getProperty(SPBus_MPlayer, "getVideoSyncMaster", NULL,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_STRING, &pValue,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: getString='%s'\n", __FUNCTION__, pValue));

        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)pValue, strlen(pValue));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        val_len = requests->requestvb->val_len;
        if (val_len > 32) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }
        pValue = netsnmp_strdup_and_null(requests->requestvb->val.string, val_len);
        DEBUGMSGTL(("Interface", "%s: setString='%s'\n", __FUNCTION__, pValue));

        if (DBus_setProperty(SPBus_MPlayer, "setVideoSyncMaster", NULL,
                             DBUS_TYPE_STRING, &pValue,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        }
        SNMP_FREE(pValue);
        break;
    
    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_videoSyncMaster\n", reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_outputSpdifMode(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info *reqinfo,
                       netsnmp_request_info *requests)
{
    int ret, value;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        if (DBus_getProperty(SPBus_MPlayer, "getOutputSpdifMode", NULL,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: getInt='%d'\n", __FUNCTION__, value));

        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value, sizeof(value));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION: 
        value = *requests->requestvb->val.integer;
        DEBUGMSGTL(("Interface", "%s: setInt='%d'\n", __FUNCTION__, value));
        if (value < 0 || value > 2) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }
        if (DBus_setProperty(SPBus_MPlayer, "setOutputSpdifMode", NULL,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_outputSpdifMode\n", reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_HtmlEvalJavascript(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    int ret, val_len;
    const char *pValue;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        if (DBus_getProperty(SPBus_ControlCenter_UiSrv, "getHtmlEvalJavascript", NULL,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_STRING, &pValue,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: getString='%s'\n", __FUNCTION__, pValue));

        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)pValue, strlen(pValue));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        val_len = requests->requestvb->val_len;
        if (val_len > 4096) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }
        pValue = netsnmp_strdup_and_null(requests->requestvb->val.string, val_len);
        DEBUGMSGTL(("Interface", "%s: setString='%s'\n", __FUNCTION__, pValue));

        if (DBus_setProperty(SPBus_ControlCenter_UiSrv, "setHtmlEvalJavascript", NULL,
                             DBUS_TYPE_STRING, &pValue,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        }
        SNMP_FREE(pValue);
        break;
    
    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_HtmlEvalJavascript\n", reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
	handle_VideoLayerPlayMedia(netsnmp_mib_handler *handler,
	netsnmp_handler_registration *reginfo,
	netsnmp_agent_request_info *reqinfo,
	netsnmp_request_info *requests)
{
	int ret, val_len;
	const char *pValue;

	UNUSED(handler);
	UNUSED(reginfo);

	switch (reqinfo->mode) {
	case MODE_GET:
		pValue = "";
		DEBUGMSGTL(("Interface", "%s: getString='%s'\n", __FUNCTION__, pValue));
		snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
			(u_char *)pValue, 0);
		break;

	case MODE_SET_RESERVE1:
		ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
		if (ret != SNMP_ERR_NOERROR) {
			netsnmp_set_request_error(reqinfo, requests, ret);
		}
		break;

	case MODE_SET_RESERVE2:
		break;

	case MODE_SET_FREE:
		break;

	case MODE_SET_ACTION:
		val_len = requests->requestvb->val_len;
		if (val_len > 4096) {
			netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
			break;
		}
		pValue = netsnmp_strdup_and_null(requests->requestvb->val.string, val_len);
		DEBUGMSGTL(("Interface", "%s: setString='%s'\n", __FUNCTION__, pValue));

		if (DBus_setProperty(SPBus_ControlCenter_UiSrv, "setVideoLayerPlayMedia", NULL,
			DBUS_TYPE_STRING, &pValue,
			DBUS_TYPE_INVALID) != 0) {
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
		}
		SNMP_FREE(pValue);
		break;

	case MODE_SET_COMMIT:
		break;

	case MODE_SET_UNDO:
		break;

	default:
		snmp_log(LOG_ERR, "unknown mode (%d) in handle_VideoLayerPlayMedia\n", reqinfo->mode);
		return SNMP_ERR_GENERR;
	}

	return SNMP_ERR_NOERROR;
}

int
	handle_HtmlLayerPlay(netsnmp_mib_handler *handler,
	netsnmp_handler_registration *reginfo,
	netsnmp_agent_request_info *reqinfo,
	netsnmp_request_info *requests)
{
	int ret, val_len;
	const char *pValue;

	UNUSED(handler);
	UNUSED(reginfo);

	switch (reqinfo->mode) {
	case MODE_GET:
		pValue = "";
		DEBUGMSGTL(("Interface", "%s: getString='%s'\n", __FUNCTION__, pValue));
		snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
			(u_char *)pValue, 0);
		break;

	case MODE_SET_RESERVE1:
		ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
		if (ret != SNMP_ERR_NOERROR) {
			netsnmp_set_request_error(reqinfo, requests, ret);
		}
		break;

	case MODE_SET_RESERVE2:
		break;

	case MODE_SET_FREE:
		break;

	case MODE_SET_ACTION:
		val_len = requests->requestvb->val_len;
		if (val_len > 4096) {
			netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
			break;
		}
		pValue = netsnmp_strdup_and_null(requests->requestvb->val.string, val_len);
		DEBUGMSGTL(("Interface", "%s: setString='%s'\n", __FUNCTION__, pValue));

		if (DBus_setProperty(SPBus_ControlCenter_UiSrv, "setHtmlLayerPlay", NULL,
			DBUS_TYPE_STRING, &pValue,
			DBUS_TYPE_INVALID) != 0) {
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
		}
		SNMP_FREE(pValue);
		break;

	case MODE_SET_COMMIT:
		break;

	case MODE_SET_UNDO:
		break;

	default:
		snmp_log(LOG_ERR, "unknown mode (%d) in handle_VideoLayerPlayMedia\n", reqinfo->mode);
		return SNMP_ERR_GENERR;
	}

	return SNMP_ERR_NOERROR;
}

int
handle_playNext(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    int ret;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *) "", 0);
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:

        if (DBus_setProperty(SPBus_ControlCenter_UiSrv, "setPlayNext", NULL,NULL) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_playBrowser\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_videoRotation(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info *reqinfo,
                       netsnmp_request_info *requests)
{
    int ret, value;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        if (DBus_getProperty(SPBus_MPlayer, "getVideoRotation", NULL,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: getInt='%d'\n", __FUNCTION__, value));

        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value, sizeof(value));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION: 
        value = *requests->requestvb->val.integer;
        DEBUGMSGTL(("Interface", "%s: setInt='%d'\n", __FUNCTION__, value));
        if (value < 0 || value > 3) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }
        if (DBus_setProperty(SPBus_MPlayer, "setVideoRotation", NULL,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_videoRotation\n", reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/*added by bert 2016/10/12*/
#if 1
int
handle_playSmooth(netsnmp_mib_handler *handler,
                              netsnmp_handler_registration *reginfo,
                              netsnmp_agent_request_info *reqinfo,
                              netsnmp_request_info *requests)
{
    int ret;
	int iSnmpErrNo = SNMP_ERR_NOERROR;
	int iRet;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
	{
		SharedPtr <CDBusMessage> DbusMsgCall_sp;
		DbusMsgCall_sp = CDBusMessage::createMethodCall(DBUS_MPLAYER_SERVICE_NAME,
			DBUS_MPLAYER_OBJECT_PATH, DBUS_MPLAYER_OBJECT_INTERFACE, METHOD_getHDRAsync);
		if(DbusMsgCall_sp.isNull())
		{
			iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
			break;
		}
		SharedPtr <CDBusParameterList> DbusParamListToSend_sp(new CDBusParameterList);
		if(DbusParamListToSend_sp.isNull())
		{
			iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
			break;
		}

		try
		{
			(*DbusParamListToSend_sp) << 0;
		}
		catch(std::bad_alloc & BadAllocEx)
		{
			iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
			break;
		}
		iRet = ((*DbusParamListToSend_sp) >> DbusMsgCall_sp);
		if(ERROR_SUCCESS != iRet)
		{
			iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
			break;
		}

		SharedPtr <CDBusMessage> DbusMsgReply_sp;
		DbusMsgReply_sp = CDbusConnection::Call(connectToDBus(), DbusMsgCall_sp, DBUS_CALL_DEFAULT_TIMEOUT_MS);
		if(DbusMsgReply_sp.isNull())
		{
			iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
			break;
		}
		SharedPtr <CDBusParameterList> DbusParamListReceived_sp(new CDBusParameterList);
		if(DbusParamListReceived_sp.isNull())
		{
			iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
			break;
		}
		(*DbusParamListReceived_sp) << (*DbusMsgReply_sp);
		if(2 > DbusParamListReceived_sp->getSize())
		{
			iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
			break;
		}

		iRet = (*DbusParamListReceived_sp)[0]->toInt32();
		if(ERROR_SUCCESS != iRet)
		{
			iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
			break;
		}

		INT_t iSnmpDispResolution = (*DbusParamListReceived_sp)[1]->toInt32();
		if (0 == iSnmpDispResolution)
			iSnmpDispResolution = 1;
		else
			iSnmpDispResolution = 0;
		iRet = snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER, iSnmpDispResolution);
		if(0 != iRet)
		{
			iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
			break;
		}
		break;		
	}

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
	{
		int iSnmpDispResVal = *(requests->requestvb->val.integer);
		SharedPtr <CDBusMessage> DbusMsgCall_sp;
		DbusMsgCall_sp = CDBusMessage::createMethodCall(DBUS_MPLAYER_SERVICE_NAME,
			DBUS_MPLAYER_OBJECT_PATH, DBUS_MPLAYER_OBJECT_INTERFACE, METHOD_setHDRAsync);

		if(DbusMsgCall_sp.isNull())
		{
			iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
			break;
		}
		SharedPtr <CDBusParameterList> DbusParamListToSend_sp(new CDBusParameterList);
		if(DbusParamListToSend_sp.isNull())
		{
			iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
			break;
		}
		if (0 == iSnmpDispResVal)
			iSnmpDispResVal = 1;
		else if (1 == iSnmpDispResVal)
			iSnmpDispResVal = 0;		

		int smoothMode = iSnmpDispResVal;
		/*LOG_LINE("iSnmpDispResVal(we set value):%d,smoothMode(labs table value):%d\n",iSnmpDispResVal,smoothMode);*/

		if((0>smoothMode) || (1<smoothMode))
		{
			iSnmpErrNo = SNMP_ERR_WRONGVALUE;
			break;
		}

		try
		{
			(*DbusParamListToSend_sp) << smoothMode;
		}
		catch(std::bad_alloc & BadAllocEx)
		{
			iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
			break;
		}
		iRet = ((*DbusParamListToSend_sp) >> DbusMsgCall_sp);
		if(ERROR_SUCCESS != iRet)
		{
			iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
			break;
		}	

		SharedPtr <CDBusMessage> DbusMsgReply_sp;
		DbusMsgReply_sp = CDbusConnection::Call(connectToDBus(), DbusMsgCall_sp, DBUS_CALL_DEFAULT_TIMEOUT_MS);
		if(DbusMsgReply_sp.isNull())
		{
			iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
			break;
		}
		SharedPtr <CDBusParameterList> DbusParamListReceived_sp(new CDBusParameterList);
		if(DbusParamListReceived_sp.isNull())
		{
			iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
			break;
		}
		(*DbusParamListReceived_sp) << (*DbusMsgReply_sp);
		if(1 > DbusParamListReceived_sp->getSize())
		{
			iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
			break;
		}
		iRet = (*DbusParamListReceived_sp)[0]->toInt32();
		if(ERROR_SUCCESS != iRet)
		{
			iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
			break;
		}
		break;
	}

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_Smooth\n",
                 reqinfo->mode);
        iSnmpErrNo = SNMP_ERR_GENERR;
    }

    return iSnmpErrNo;
}
#endif


