/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf 17337 2009-01-01 14:28:29Z magfr $
 */

#ifndef	ALLOW_OS_CODE
#define	ALLOW_OS_CODE
#endif	//ALLOW_OS_CODE

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "subagent.h"
#include "monitor.h"
#include <DbusConnection.h>
#include <math2.h>
#include <SnmpCmdConv.h>

static MonitorConfig config;
static MonitorConfig *pSetting;

/** Initializes the monitor module */
void
init_monitor(MonitorConfig *setting)
{
	int iRet = 0;
	
    const oid       monitorType_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 2, 1 };
    const oid       monitorModel_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 2, 2 };
    const oid       serialControlData_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 2, 3 };
    const oid       monitorPower_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 2, 4 };
    const oid       monitorInput_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 2, 5 };
    const oid       monitorVolume_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 2, 6 };
    const oid       monitorFrontPanel_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 2, 7 };
    const oid       monitorMute_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 2, 8 };
    const oid       videoDisplayResolution_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 2, 9 };
    const oid       videoInterlacing_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 2, 10 };
    const oid       videoInterlacingValue_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 2, 11 };
    const oid       monitorLocation_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 2, 12 };
    const oid       monitorProtocol_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 2, 13 };
    const oid       serialParameters_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 2, 14 };
    const oid       passthruBufferEnable_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 2, 15 };
    const oid       passthruBufferSize_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 2, 16 };
    const oid       DConfiguration_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 2, 17 };
	const oid       DisplayOutputMode_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 2, 18 };
	
	const oid       videoColorSpace_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 2, 19 };

	const oid       videoColorDepth_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 2, 20 };

	const oid       Matrixcoefficients_oid[] =
        { 1, 3, 6, 1, 4, 1, 38010, 3, 2, 21 };


    DEBUGMSGTL(("monitor", "Initializing\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("monitorType", handle_monitorType,
                             monitorType_oid, OID_LENGTH(monitorType_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("monitorModel", handle_monitorModel,
                             monitorModel_oid,
                             OID_LENGTH(monitorModel_oid),
                             HANDLER_CAN_RONLY));
    iRet = netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("serialControlData", handle_serialControlData,
                             serialControlData_oid,
                             OID_LENGTH(serialControlData_oid),
                             HANDLER_CAN_RWRITE));
	if(MIB_REGISTERED_OK != iRet)
	{
		DEBUGMSGTL(("SnmpAgent", "[%s:%d]Ret=%d\n", SRC_FILE_NAME, __LINE__, iRet));
	}
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("monitorPower", handle_monitorPower,
                             monitorPower_oid,
                             OID_LENGTH(monitorPower_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("monitorInput", handle_monitorInput,
                             monitorInput_oid,
                             OID_LENGTH(monitorInput_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("monitorVolume", handle_monitorVolume,
                             monitorVolume_oid,
                             OID_LENGTH(monitorVolume_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("monitorFrontPanel", handle_monitorFrontPanel,
                             monitorFrontPanel_oid,
                             OID_LENGTH(monitorFrontPanel_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("monitorMute", handle_monitorMute,
                             monitorMute_oid, OID_LENGTH(monitorMute_oid),
                             HANDLER_CAN_RWRITE));
    iRet = netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("videoDisplayResolution",
                             handle_videoDisplayResolution,
                             videoDisplayResolution_oid,
                             OID_LENGTH(videoDisplayResolution_oid),
                             HANDLER_CAN_RWRITE));
	if(MIB_REGISTERED_OK != iRet)
	{
		DEBUGMSGTL(("SnmpAgent", "[%s:%d]Ret=%d\n", SRC_FILE_NAME, __LINE__, iRet));
	}
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("videoInterlacing", handle_videoInterlacing,
                             videoInterlacing_oid,
                             OID_LENGTH(videoInterlacing_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("videoInterlacingValue",
                             handle_videoInterlacingValue,
                             videoInterlacingValue_oid,
                             OID_LENGTH(videoInterlacingValue_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("monitorLocation", handle_monitorLocation,
                             monitorLocation_oid,
                             OID_LENGTH(monitorLocation_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("monitorProtocol", handle_monitorProtocol,
                             monitorProtocol_oid,
                             OID_LENGTH(monitorProtocol_oid),
                             HANDLER_CAN_RWRITE));
    iRet = netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("serialParameters", handle_serialParameters,
                             serialParameters_oid,
                             OID_LENGTH(serialParameters_oid),
                             HANDLER_CAN_RWRITE));
	if(MIB_REGISTERED_OK != iRet)
	{
		DEBUGMSGTL(("SnmpAgent", "[%s:%d]Ret=%d\n", SRC_FILE_NAME, __LINE__, iRet));
	}
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("passthruBufferEnable",
                             handle_passthruBufferEnable,
                             passthruBufferEnable_oid,
                             OID_LENGTH(passthruBufferEnable_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("passthruBufferSize",
                             handle_passthruBufferSize,
                             passthruBufferSize_oid,
                             OID_LENGTH(passthruBufferSize_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("3DConfiguration", handle_3DConfiguration,
                             DConfiguration_oid,
                             OID_LENGTH(DConfiguration_oid),
                             HANDLER_CAN_RWRITE));
	netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("DisplayOutputMode", handle_DisplayOutputMode,
                             DisplayOutputMode_oid,
                             OID_LENGTH(DisplayOutputMode_oid),
                             HANDLER_CAN_RWRITE));

	pSetting = setting;
    memcpy(&config, setting, sizeof(config));
}

int
handle_monitorType(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    int ret, value;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        if (DBus_getProperty(SPBus_MPlayer, "MibgetMonitorInfo", NULL,
                             DBUS_TYPE_INT32, &ret,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        if (ret != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHOBJECT);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: getInt='%d'\n", __FUNCTION__, value));

        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&value, sizeof(value));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        value = *requests->requestvb->val.integer;
        if (value < 0 || value > 8) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
            break;
        }
        DEBUGMSGTL(("Interface", "%s: setInt='%d'\n", __FUNCTION__, value));

        if (DBus_setProperty(SPBus_MPlayer, "MibsetMonitorInfo", NULL,
                             DBUS_TYPE_INT32, &value,
                             DBUS_TYPE_INVALID) != 0) {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            break;
        }
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_monitorType\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_monitorModel(netsnmp_mib_handler *handler,
                    netsnmp_handler_registration *reginfo,
                    netsnmp_agent_request_info *reqinfo,
                    netsnmp_request_info *requests)
{
    UNUSED(handler);
    UNUSED(reginfo);
    UNUSED(requests);

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *) config.model , strlen(config.model));
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_monitorModel\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_serialControlData(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests)
{
	int iSnmpErrNo = SNMP_ERR_NOERROR;
	int iRet;
    int ret;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
	    case MODE_GET:
		{
			SharedPtr <CDBusMessage> DbusMsgCall_sp;
			DbusMsgCall_sp = CDBusMessage::createMethodCall(DBUS_MPLAYER_SERVICE_NAME,
				DBUS_MPLAYER_OBJECT_PATH, DBUS_MPLAYER_OBJECT_INTERFACE,
				DBUS_METHOD_getSerialControlData);
			if(DbusMsgCall_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			SharedPtr <CDBusMessage> DbusMsgReply_sp;
			DbusMsgReply_sp = CDbusConnection::Call(connectToDBus(), DbusMsgCall_sp, DBUS_CALL_DEFAULT_TIMEOUT_MS);
			if(DbusMsgReply_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			SharedPtr <CDBusParameterList> DbusParamListReceived_sp(new CDBusParameterList);
			if(DbusParamListReceived_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			(*DbusParamListReceived_sp) << (*DbusMsgReply_sp);
			if(2 > DbusParamListReceived_sp->getSize())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			iRet = (*DbusParamListReceived_sp)[0]->toInt32();
			if(ERROR_SUCCESS != iRet)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			CString strSerialControlData = (*DbusParamListReceived_sp)[1]->toString();
			iRet = snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, 
				(LPCSTR)strSerialControlData, strSerialControlData.GetStrLength());
			if(0 != iRet)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			break;		
		}

	    case MODE_SET_RESERVE1:
	        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
	        if (ret != SNMP_ERR_NOERROR) {
	            netsnmp_set_request_error(reqinfo, requests, ret);
	        }
	        break;

	    case MODE_SET_RESERVE2:
	        break;

	    case MODE_SET_FREE:
	        break;

	    case MODE_SET_ACTION:
		{
			char szSerialControlData[1024];
			size_t StrLen = requests->requestvb->val_len;
			if(0 >= StrLen || NULL == requests->requestvb->val.string)
			{
				iSnmpErrNo = SNMP_ERR_WRONGVALUE;
				break;
			}
			memcpy(szSerialControlData, requests->requestvb->val.string, GET_MIN_VAL(sizeof(szSerialControlData)-1, StrLen));
			szSerialControlData[GET_MIN_VAL(sizeof(szSerialControlData)-1, StrLen)] = '\0';
			SharedPtr <CDBusMessage> DbusMsgCall_sp;
			DbusMsgCall_sp = CDBusMessage::createMethodCall(DBUS_MPLAYER_SERVICE_NAME,
				DBUS_MPLAYER_OBJECT_PATH, DBUS_MPLAYER_OBJECT_INTERFACE,
				DBUS_METHOD_setSerialControlData);
			if(DbusMsgCall_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			SharedPtr <CDBusParameterList> DbusParamListToSend_sp(new CDBusParameterList);
			if(DbusParamListToSend_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			try
			{
				(*DbusParamListToSend_sp) << szSerialControlData;
			}
			catch(std::bad_alloc & BadAllocEx)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			iRet = ((*DbusParamListToSend_sp) >> DbusMsgCall_sp);
			if(ERROR_SUCCESS != iRet)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}			
			SharedPtr <CDBusMessage> DbusMsgReply_sp;
			DbusMsgReply_sp = CDbusConnection::Call(connectToDBus(), DbusMsgCall_sp, DBUS_CALL_DEFAULT_TIMEOUT_MS);
			if(DbusMsgReply_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			SharedPtr <CDBusParameterList> DbusParamListReceived_sp(new CDBusParameterList);
			if(DbusParamListReceived_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			(*DbusParamListReceived_sp) << (*DbusMsgReply_sp);
			if(1 > DbusParamListReceived_sp->getSize())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			iRet = (*DbusParamListReceived_sp)[0]->toInt32();
			if(ERROR_SUCCESS != iRet)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			break;
		}

	    case MODE_SET_COMMIT:
	        if (0 /* XXX: error? */ ) {
				/*
				* try _really_really_ hard to never get to this point 
				*/
	            netsnmp_set_request_error(reqinfo, requests,
	                                      SNMP_ERR_COMMITFAILED);
	        }
	        break;

	    case MODE_SET_UNDO:
	        break;

	    default:
			/*
			* we should never get here, so this is a really bad error 
			*/
	        snmp_log(LOG_ERR,
	                 "unknown mode (%d) in handle_serialControlData\n",
	                 reqinfo->mode);
	        return SNMP_ERR_GENERR;
	}

    return iSnmpErrNo;
}

int
handle_monitorPower(netsnmp_mib_handler *handler,
                    netsnmp_handler_registration *reginfo,
                    netsnmp_agent_request_info *reqinfo,
                    netsnmp_request_info *requests)
{
    int ret, temp;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *) &config.display_power,
                                 sizeof(config.display_power));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        temp = *requests->requestvb->val.integer;
        if (temp != 0 && temp != 1) {
            netsnmp_set_request_error (reqinfo, requests, SNMP_ERR_WRONGVALUE);
            return SNMP_ERR_GENERR;
        }
        config.display_power = temp;
        break;

    case MODE_SET_COMMIT:
        if (0 /* XXX: error? */ ) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_monitorPower\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_monitorInput(netsnmp_mib_handler *handler,
                    netsnmp_handler_registration *reginfo,
                    netsnmp_agent_request_info *reqinfo,
                    netsnmp_request_info *requests)
{
    int             ret;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *) &config.display_input,
                                 sizeof(config.display_input));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        if (0 /* XXX: error? */ ) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
        break;

    case MODE_SET_COMMIT:
        if (0 /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_monitorInput\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_monitorVolume(netsnmp_mib_handler *handler,
                     netsnmp_handler_registration *reginfo,
                     netsnmp_agent_request_info *reqinfo,
                     netsnmp_request_info *requests)
{
    int ret;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *) &config.display_volume,
                                 sizeof(config.display_volume));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        config.display_volume = *requests->requestvb->val.integer;
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_monitorVolume\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_monitorFrontPanel(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests)
{
    int ret, frontp;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *) &config.display_fp, 
                                 sizeof(config.display_fp));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        frontp = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (frontp < 0 || frontp > 3) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        config.display_fp = frontp;
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_monitorFrontPanel\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_monitorMute(netsnmp_mib_handler *handler,
                   netsnmp_handler_registration *reginfo,
                   netsnmp_agent_request_info *reqinfo,
                   netsnmp_request_info *requests)
{
    int ret, mute;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *) &config.monitor_mute,
                                 sizeof(config.monitor_mute));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        mute = *requests->requestvb->val.integer;
        if (mute < 0 || mute > 1) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
            break;
        }
        config.monitor_mute = mute;
        break;

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_monitorMute\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
handle_videoDisplayResolution(netsnmp_mib_handler *handler,
                              netsnmp_handler_registration *reginfo,
                              netsnmp_agent_request_info *reqinfo,
                              netsnmp_request_info *requests)
{
    int ret;
	int iSnmpErrNo = SNMP_ERR_NOERROR;
	int iRet;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
	{
		SharedPtr <CDBusMessage> DbusMsgCall_sp;
		DbusMsgCall_sp = CDBusMessage::createMethodCall(DBUS_MPLAYER_SERVICE_NAME,
			DBUS_MPLAYER_OBJECT_PATH, DBUS_MPLAYER_OBJECT_INTERFACE, METHOD_ChangeVideoOutputMode);
		if(DbusMsgCall_sp.isNull())
		{
			iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
			break;
		}
		SharedPtr <CDBusParameterList> DbusParamListToSend_sp(new CDBusParameterList);
		if(DbusParamListToSend_sp.isNull())
		{
			iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
			break;
		}
		try
		{
			(*DbusParamListToSend_sp) << MediaPlayer::VO_MODE_NotSet;
		}
		catch(std::bad_alloc & BadAllocEx)
		{
			iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
			break;
		}
		iRet = ((*DbusParamListToSend_sp) >> DbusMsgCall_sp);
		if(ERROR_SUCCESS != iRet)
		{
			iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
			break;
		}			
		SharedPtr <CDBusMessage> DbusMsgReply_sp;
		DbusMsgReply_sp = CDbusConnection::Call(connectToDBus(), DbusMsgCall_sp, DBUS_CALL_DEFAULT_TIMEOUT_MS);
		if(DbusMsgReply_sp.isNull())
		{
			iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
			break;
		}
		SharedPtr <CDBusParameterList> DbusParamListReceived_sp(new CDBusParameterList);
		if(DbusParamListReceived_sp.isNull())
		{
			iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
			break;
		}
		(*DbusParamListReceived_sp) << (*DbusMsgReply_sp);
		if(2 > DbusParamListReceived_sp->getSize())
		{
			iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
			break;
		}
		iRet = (*DbusParamListReceived_sp)[0]->toInt32();
		if(ERROR_SUCCESS != iRet)
		{
			iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
			break;
		}
		INT_t iCurVoMode = (*DbusParamListReceived_sp)[1]->toInt32();
		int iSnmpDispResolution = getSnmpResolutionValFromMpVoMode((MediaPlayer::VIDEO_OUTPUT_MODE)iCurVoMode);
		iRet = snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER, iSnmpDispResolution);
		if(0 != iRet)
		{
			iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
			break;
		}
		break;		
	}

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
	{
		int iSnmpDispResVal = *(requests->requestvb->val.integer);
//		LOG_LINE("iSnmpDispResVal(we set value):%d\n",iSnmpDispResVal);
		SharedPtr <CDBusMessage> DbusMsgCall_sp;
		DbusMsgCall_sp = CDBusMessage::createMethodCall(DBUS_MPLAYER_SERVICE_NAME,
			DBUS_MPLAYER_OBJECT_PATH, DBUS_MPLAYER_OBJECT_INTERFACE, METHOD_setVideoOutputModeAsync);
		if(DbusMsgCall_sp.isNull())
		{
			iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
			break;
		}
		SharedPtr <CDBusParameterList> DbusParamListToSend_sp(new CDBusParameterList);
		if(DbusParamListToSend_sp.isNull())
		{
			iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
			break;
		}
		BOOL_t bFound = FALSE;
		MediaPlayer::VIDEO_OUTPUT_MODE eVoMode = getMpVoMode_From_SnmpDispResVal(iSnmpDispResVal, OUT bFound);
//		LOG_LINE("iSnmpDispResVal(we set value):%d,eVoMode(labs table value):%d\n",iSnmpDispResVal,eVoMode);
		if(FALSE == bFound)
		{
			iSnmpErrNo = SNMP_ERR_WRONGVALUE;
			break;
		}
		try
		{
			(*DbusParamListToSend_sp) << eVoMode;
		}
		catch(std::bad_alloc & BadAllocEx)
		{
			iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
			break;
		}
		iRet = ((*DbusParamListToSend_sp) >> DbusMsgCall_sp);
		if(ERROR_SUCCESS != iRet)
		{
			iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
			break;
		}			
		SharedPtr <CDBusMessage> DbusMsgReply_sp;
		DbusMsgReply_sp = CDbusConnection::Call(connectToDBus(), DbusMsgCall_sp, DBUS_CALL_DEFAULT_TIMEOUT_MS);
		if(DbusMsgReply_sp.isNull())
		{
			iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
			break;
		}
		SharedPtr <CDBusParameterList> DbusParamListReceived_sp(new CDBusParameterList);
		if(DbusParamListReceived_sp.isNull())
		{
			iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
			break;
		}
		(*DbusParamListReceived_sp) << (*DbusMsgReply_sp);
		if(1 > DbusParamListReceived_sp->getSize())
		{
			iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
			break;
		}
		iRet = (*DbusParamListReceived_sp)[0]->toInt32();
		if(ERROR_SUCCESS != iRet)
		{
			iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
			break;
		}
		break;
	}

    case MODE_SET_COMMIT:
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_videoDisplayResolution\n",
                 reqinfo->mode);
        iSnmpErrNo = SNMP_ERR_GENERR;
    }

    return iSnmpErrNo;
}

int
handle_videoInterlacing(netsnmp_mib_handler *handler,
                        netsnmp_handler_registration *reginfo,
                        netsnmp_agent_request_info *reqinfo,
                        netsnmp_request_info *requests)
{
    int ret, resolution;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *) &config.interlace,
                                 sizeof (config.interlace));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        resolution = *requests->requestvb->val.integer;
        if (resolution != 0 && resolution != 1) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
        break;

    case MODE_SET_COMMIT:
        if (0 /* XXX: error? */ ) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_videoInterlacing\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_videoInterlacingValue(netsnmp_mib_handler *handler,
                             netsnmp_handler_registration *reginfo,
                             netsnmp_agent_request_info *reqinfo,
                             netsnmp_request_info *requests)
{
    int             ret;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *) &config.interlacing_value,
                                 sizeof (config.interlacing_value));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        config.interlacing_value = *requests->requestvb->val.integer;
        if (0 /* XXX: error? */ ) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
        break;

    case MODE_SET_COMMIT:
        if (0 /* XXX: error? */ ) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_videoInterlacingValue\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_monitorLocation(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info *reqinfo,
                       netsnmp_request_info *requests)
{
    int ret, val_len;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *) config.install_place,
                                 strlen(config.install_place));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        val_len = requests->requestvb->val_len;
        if (val_len > INSTALL_PLACE_LEN) {
            netsnmp_set_request_error (reqinfo, requests, SNMP_ERR_WRONGLENGTH);
            break;
        }
        memcpy(config.install_place, requests->requestvb->val.string, val_len);
        config.install_place[val_len] = 0;
        break;

    case MODE_SET_COMMIT:
        if (0 /* XXX: error? */ ) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_monitorLocation\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_monitorProtocol(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info *reqinfo,
                       netsnmp_request_info *requests)
{
    int             ret;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *) &config.protocol,
                                 sizeof(config.protocol));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        config.protocol = *requests->requestvb->val.integer;
        if (0 /* XXX: error? */ ) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
        break;

    case MODE_SET_COMMIT:
        if (0 /* XXX: error? */ ) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_monitorProtocol\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_serialParameters(netsnmp_mib_handler *handler,
                        netsnmp_handler_registration *reginfo,
                        netsnmp_agent_request_info *reqinfo,
                        netsnmp_request_info *requests)
{
	int iSnmpErrNo = SNMP_ERR_NOERROR;
	int iRet;
    int ret, val_len;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
	    case MODE_GET:
		{
			SharedPtr <CDBusMessage> DbusMsgCall_sp;
			DbusMsgCall_sp = CDBusMessage::createMethodCall(DBUS_MPLAYER_SERVICE_NAME,
				DBUS_MPLAYER_OBJECT_PATH, DBUS_MPLAYER_OBJECT_INTERFACE,
				DBUS_METHOD_getSerialParameters);
			if(DbusMsgCall_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			SharedPtr <CDBusMessage> DbusMsgReply_sp;
			DbusMsgReply_sp = CDbusConnection::Call(connectToDBus(), DbusMsgCall_sp, DBUS_CALL_DEFAULT_TIMEOUT_MS);
			if(DbusMsgReply_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			SharedPtr <CDBusParameterList> DbusParamListReceived_sp(new CDBusParameterList);
			if(DbusParamListReceived_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			(*DbusParamListReceived_sp) << (*DbusMsgReply_sp);
			if(2 > DbusParamListReceived_sp->getSize())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			iRet = (*DbusParamListReceived_sp)[0]->toInt32();
			if(ERROR_SUCCESS != iRet)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			CString strSerialParameters = (*DbusParamListReceived_sp)[1]->toString();
			iRet = snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, 
				(LPCSTR)strSerialParameters, strSerialParameters.GetStrLength());
			if(0 != iRet)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			break;		
		}

	    case MODE_SET_RESERVE1:
	        ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
	        if (ret != SNMP_ERR_NOERROR) {
	            netsnmp_set_request_error(reqinfo, requests, ret);
	        }
	        break;

	    case MODE_SET_RESERVE2:
	        val_len = requests->requestvb->val_len;
	        if (val_len > SERIAL_PARM_LEN) {
	            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGLENGTH);
	            break;
	        }
	        memcpy(config.serial_parameters, requests->requestvb->val.string, val_len);
	        config.serial_parameters[val_len] = 0;
	        break;

	    case MODE_SET_FREE:
	        break;

	    case MODE_SET_ACTION:
		{
			char szSerialParameters[32];
			size_t StrLen = requests->requestvb->val_len;
			if(0 >= StrLen || NULL == requests->requestvb->val.string)
			{
				iSnmpErrNo = SNMP_ERR_WRONGVALUE;
				break;
			}
			memcpy(szSerialParameters, requests->requestvb->val.string, GET_MIN_VAL(sizeof(szSerialParameters)-1, StrLen));
			szSerialParameters[GET_MIN_VAL(sizeof(szSerialParameters)-1, StrLen)] = '\0';
			SharedPtr <CDBusMessage> DbusMsgCall_sp;
			DbusMsgCall_sp = CDBusMessage::createMethodCall(DBUS_MPLAYER_SERVICE_NAME,
				DBUS_MPLAYER_OBJECT_PATH, DBUS_MPLAYER_OBJECT_INTERFACE,
				DBUS_METHOD_setSerialParameters);
			if(DbusMsgCall_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			SharedPtr <CDBusParameterList> DbusParamListToSend_sp(new CDBusParameterList);
			if(DbusParamListToSend_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			try
			{
				(*DbusParamListToSend_sp) << szSerialParameters;
			}
			catch(std::bad_alloc & BadAllocEx)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			iRet = ((*DbusParamListToSend_sp) >> DbusMsgCall_sp);
			if(ERROR_SUCCESS != iRet)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}			
			SharedPtr <CDBusMessage> DbusMsgReply_sp;
			DbusMsgReply_sp = CDbusConnection::Call(connectToDBus(), DbusMsgCall_sp, DBUS_CALL_DEFAULT_TIMEOUT_MS);
			if(DbusMsgReply_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			SharedPtr <CDBusParameterList> DbusParamListReceived_sp(new CDBusParameterList);
			if(DbusParamListReceived_sp.isNull())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			(*DbusParamListReceived_sp) << (*DbusMsgReply_sp);
			if(1 > DbusParamListReceived_sp->getSize())
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			iRet = (*DbusParamListReceived_sp)[0]->toInt32();
			if(ERROR_SUCCESS != iRet)
			{
				iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
				break;
			}
			break;
		}
	    case MODE_SET_COMMIT:
	        if (0 /* XXX: error? */ ) {
	            netsnmp_set_request_error(reqinfo, requests,
	                                      SNMP_ERR_COMMITFAILED);
	        }
	        break;

	    case MODE_SET_UNDO:
	        break;

	    default:
	        snmp_log(LOG_ERR, "unknown mode (%d) in handle_serialParameters\n",
	                 reqinfo->mode);
	        return SNMP_ERR_GENERR;
    }

    return iSnmpErrNo;
}

int
handle_passthruBufferEnable(netsnmp_mib_handler *handler,
                            netsnmp_handler_registration *reginfo,
                            netsnmp_agent_request_info *reqinfo,
                            netsnmp_request_info *requests)
{
    int ret, enable;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *) &config.passthru_buffer_enable,
				 sizeof(config.passthru_buffer_enable));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        enable = *requests->requestvb->val.integer;
        if (enable != 0 && enable !=  1) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
        config.passthru_buffer_enable = enable;
        break;

    case MODE_SET_COMMIT:
        if (0 /* XXX: error? */ ) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_passthruBufferEnable\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_passthruBufferSize(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    int ret, size;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *) &config.passthru_buffer_size,
				 sizeof(config.passthru_buffer_size));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
	size = *requests->requestvb->val.integer;
        if ((size < 1) || (size > 4)) {
	   netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
           break;
        }
	config.passthru_buffer_size = size;
        break;

    case MODE_SET_COMMIT:
        if (0 /* XXX: error? */ ) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_passthruBufferSize\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_3DConfiguration(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info *reqinfo,
                       netsnmp_request_info *requests)
{
    int ret, temp;

    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *) &config.video3d_config,
                                 sizeof(config.video3d_config));
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
	temp = *requests->requestvb->val.integer;
        if ((temp < 0) || (temp > 3)) {
	   netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
           break;
        }
	config.video3d_config = temp;
        break;

    case MODE_SET_COMMIT:
        if (0 /* XXX: error? */ ) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_3DConfiguration\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_DisplayOutputMode(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info *reqinfo,
                       netsnmp_request_info *requests)
{
    int ret, temp;
	int iRet;
	int iSnmpErrNo = SNMP_ERR_NOERROR;
	
    UNUSED(handler);
    UNUSED(reginfo);

    switch (reqinfo->mode) {
    case MODE_GET:
    {
		SharedPtr <CDBusMessage> DbusMsgCall_sp;
		DbusMsgCall_sp = CDBusMessage::createMethodCall(DBUS_MPLAYER_SERVICE_NAME,
			DBUS_MPLAYER_OBJECT_PATH, DBUS_MPLAYER_OBJECT_INTERFACE, METHOD_getDisplayOutputMode);
		if(DbusMsgCall_sp.isNull())
		{
			iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
			break;
		}
			
		SharedPtr <CDBusMessage> DbusMsgReply_sp;
		DbusMsgReply_sp = CDbusConnection::Call(connectToDBus(), DbusMsgCall_sp, DBUS_CALL_DEFAULT_TIMEOUT_MS);
		if(DbusMsgReply_sp.isNull())
		{
			iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
			break;
		}
		SharedPtr <CDBusParameterList> DbusParamListReceived_sp(new CDBusParameterList);
		if(DbusParamListReceived_sp.isNull())
		{
			iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
			break;
		}
		(*DbusParamListReceived_sp) << (*DbusMsgReply_sp);
		if(2 > DbusParamListReceived_sp->getSize())
		{
			iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
			break;
		}
		iRet = (*DbusParamListReceived_sp)[0]->toInt32();
		if(ERROR_SUCCESS != iRet)
		{
			iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
			break;
		}
		
		INT_t displayMode = (*DbusParamListReceived_sp)[1]->toInt32();
		iRet = snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER, displayMode);
		if(0 != iRet)
		{
			iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
			break;
		}
		break;		
	}

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
	{
		int displayMode = *(requests->requestvb->val.integer);
		LOG_LINE("displayMode(we set value):%d\n",displayMode);
		
		SharedPtr <CDBusMessage> DbusMsgCall_sp;
		DbusMsgCall_sp = CDBusMessage::createMethodCall(DBUS_MPLAYER_SERVICE_NAME,
			DBUS_MPLAYER_OBJECT_PATH, DBUS_MPLAYER_OBJECT_INTERFACE, METHOD_setDisplayOutputMode);
		if(DbusMsgCall_sp.isNull())
		{
			iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
			break;
		}
		SharedPtr <CDBusParameterList> DbusParamListToSend_sp(new CDBusParameterList);
		if(DbusParamListToSend_sp.isNull())
		{
			iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
			break;
		}

		try
		{
			(*DbusParamListToSend_sp) << displayMode;
		}
		catch(std::bad_alloc & BadAllocEx)
		{
			iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
			break;
		}
		iRet = ((*DbusParamListToSend_sp) >> DbusMsgCall_sp);
		if(ERROR_SUCCESS != iRet)
		{
			iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
			break;
		}			
		SharedPtr <CDBusMessage> DbusMsgReply_sp;
		DbusMsgReply_sp = CDbusConnection::Call(connectToDBus(), DbusMsgCall_sp, DBUS_CALL_DEFAULT_TIMEOUT_MS);
		if(DbusMsgReply_sp.isNull())
		{
			iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
			break;
		}
		SharedPtr <CDBusParameterList> DbusParamListReceived_sp(new CDBusParameterList);
		if(DbusParamListReceived_sp.isNull())
		{
			iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
			break;
		}
		(*DbusParamListReceived_sp) << (*DbusMsgReply_sp);
		if(1 > DbusParamListReceived_sp->getSize())
		{
			iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
			break;
		}
		iRet = (*DbusParamListReceived_sp)[0]->toInt32();
		if(ERROR_SUCCESS != iRet)
		{
			iSnmpErrNo = SNMP_ERR_RESOURCEUNAVAILABLE;
			break;
		}
		break;
	}

    case MODE_SET_COMMIT:
        if (0 /* XXX: error? */ ) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        break;

    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_3DConfiguration\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

