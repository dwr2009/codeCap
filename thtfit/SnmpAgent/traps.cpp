/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.notify.conf 17455 2009-04-05 09:53:29Z magfr $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include <dbus/dbus.h>
#include <pthread.h>

#include "traps.h"
#include "dbus.h"
#include <ErrPrintHelper.h>
#include <BaseErrDef.h>
#include "subagent.h"

#ifdef	SRC_FILE_NAME
#undef	SRC_FILE_NAME
#endif	//SRC_FILE_NAME
#define	SRC_FILE_NAME			"traps.c"

#define UNUSED(x) (void)x

extern int netsnmp_running;
static INT_t TrapThread_WaitForFinished();

extern int getWifiCfg();

static const oid snmptrap_oid[] = { 1, 3, 6, 1, 6, 3, 1, 1, 4, 1, 0 };
static pthread_t g_TrapThreadId = 0;
static BOOL_t g_bExitTrapThread = FALSE;

int send_tnetReady_trap(void)
{
    netsnmp_variable_list *var_list = NULL;
    oid tnetReady_oid[] = { 1, 3, 6, 1, 4, 1, 38010, 3, 6, 1 };

	do
	{
	    snmp_varlist_add_variable(&var_list,
	                              snmptrap_oid, OID_LENGTH(snmptrap_oid),
	                              ASN_OBJECT_ID,
	                              tnetReady_oid,
	                              sizeof(tnetReady_oid));
		if(NULL == var_list)
		{
			break;
		}
	    send_v2trap(var_list);
	    snmp_free_varbind(var_list);
	}while(FALSE);
	
    return SNMP_ERR_NOERROR;
}

int send_restartInitiated_trap(void)
{
    netsnmp_variable_list *var_list = NULL;
    oid restartInitiated_oid[] = { 1, 3, 6, 1, 4, 1, 38010, 3, 6, 2 };

    snmp_varlist_add_variable(&var_list,
                              snmptrap_oid, OID_LENGTH(snmptrap_oid),
                              ASN_OBJECT_ID,
                              restartInitiated_oid,
                              sizeof(restartInitiated_oid));

    send_v2trap(var_list);
    snmp_free_varbind(var_list);
    return SNMP_ERR_NOERROR;
}

int send_gpioInterrupt_trap(int keyNum, int keyPress)
{
    netsnmp_variable_list *var_list = NULL;
    oid gpioInterrupt_oid[] = { 1, 3, 6, 1, 4, 1, 38010, 3, 6, 6 };

	//LOG_BLINE("send_gpioInterrupt_trap\n");

	do
	{
	    snmp_varlist_add_variable(&var_list,
	                              snmptrap_oid, OID_LENGTH(snmptrap_oid),
	                              ASN_OBJECT_ID,
	                              gpioInterrupt_oid,
	                              sizeof(gpioInterrupt_oid));
		if(NULL == var_list)
		{
			break;
		}
	    snmp_varlist_add_variable(&var_list,
	                              snmptrap_oid, OID_LENGTH(snmptrap_oid),
	                              ASN_INTEGER,
	                              (u_char *) &keyNum,
	                              sizeof(keyNum));
	    snmp_varlist_add_variable(&var_list,
	                              snmptrap_oid, OID_LENGTH(snmptrap_oid),
	                              ASN_INTEGER,
	                              (u_char *) &keyPress,
	                              sizeof(keyPress));
	    send_v2trap(var_list);
	}while(FALSE);

	if(var_list)
	{
    	snmp_free_varbind(var_list);
		var_list = NULL;
	}
	
    return SNMP_ERR_NOERROR;
}

int send_wifiStatus_trap(int status, const char *msg)
{
	netsnmp_variable_list *pVarList = NULL;
    netsnmp_variable_list *var_list = NULL;
    oid wifiStatus_oid[] = { 1, 3, 6, 1, 4, 1, 38010, 3, 6, 7 };

    //LOG_BLINE("send_wifiStatus_trap\n");

	do
	{
	    pVarList = snmp_varlist_add_variable(&var_list,
	                              snmptrap_oid, OID_LENGTH(snmptrap_oid),
	                              ASN_OBJECT_ID,
	                              wifiStatus_oid,
	                              sizeof(wifiStatus_oid));
		if(NULL == pVarList)
		{
			LOG_BLINE("snmp_varlist_add_variable err\n");
			break;
		}
	    pVarList = snmp_varlist_add_variable(&var_list,
	                              snmptrap_oid, OID_LENGTH(snmptrap_oid),
	                              ASN_INTEGER,
	                              (u_char *) &status, 
	                              sizeof(status));
		if(NULL == pVarList)
		{
			LOG_BLINE("snmp_varlist_add_variable err\n");
			break;
		}
	    pVarList = snmp_varlist_add_variable(&var_list,
	                              snmptrap_oid, OID_LENGTH(snmptrap_oid),
	                              ASN_OCTET_STR,
	                              (u_char *) &msg,
	                              strlen(msg));
		if(NULL == pVarList)
		{
			LOG_BLINE("snmp_varlist_add_variable err\n");
			break;
		}
	    send_v2trap(var_list);
	}while(FALSE);

	if(var_list)
	{
		snmp_free_varbind(var_list);
		var_list = NULL;
	}
	
    return SNMP_ERR_NOERROR;
}

void* HandleDBusSignalWorker(void *arg)
{
    DBusConnection *conn = NULL;
    DBusMessage *msg = NULL;
    DBusError err;
	dbus_bool_t bDbusRet = FALSE;
	int WaitDbusTimeoutMs = (2*1000);

    UNUSED(arg);

    DEBUGMSGTL(("DBus", "%s thread stared ...\n", __FUNCTION__));

    dbus_error_init(&err);
    conn = dbus_bus_get_private(DBUS_BUS_SYSTEM, &err);
    if (dbus_error_is_set(&err)) {
        LOG_AND_FREE_DBUS_ERROR(&err);
		dbus_error_free(&err);
        goto lose;
    }
    dbus_connection_set_exit_on_disconnect(conn, FALSE);

    dbus_error_init(&err);
    dbus_bus_add_match(conn, "type='signal', interface='" DBUS_WebBrowser_DataCommSrv_IFC "'", &err);
    if (dbus_error_is_set(&err)) {
        LOG_AND_FREE_DBUS_ERROR(&err);
		dbus_error_free(&err);
        goto lose;
    }
    dbus_bus_add_match(conn, "type='signal', interface='" DBUS_GpioBtnInput_IFC "'", &err);
    if (dbus_error_is_set(&err)) {
        LOG_AND_FREE_DBUS_ERROR(&err);
        dbus_error_free(&err);
        goto lose;
    }
    dbus_bus_add_match(conn, "type='signal', interface='" DBUS_SystemService_NetworkManagerSrv_IFC "'", &err);
    if (dbus_error_is_set(&err)) {
        LOG_AND_FREE_DBUS_ERROR(&err);
		dbus_error_free(&err);
        goto lose;
    }
    dbus_bus_add_match(conn, "type='signal', interface='" DBUS_OBJ_IF_SNMP_AGENT "'", &err);
    if (dbus_error_is_set(&err)) {
        LOG_AND_FREE_DBUS_ERROR(&err);
		dbus_error_free(&err);
        goto lose;
    }

    while (netsnmp_running) {
        bDbusRet = dbus_connection_read_write(conn, WaitDbusTimeoutMs);

		if(g_bExitTrapThread)
		{
			break;
		}

		while(TRUE)
		{
	        msg = dbus_connection_pop_message(conn);
			if(NULL == msg)
			{
				break;
			}

	        if ((dbus_message_get_type(msg) == DBUS_MESSAGE_TYPE_SIGNAL)) {

	            DEBUGMSGTL(("DBus", "%s: Received signal %s:%s from %s\n", __FUNCTION__,
	                        dbus_message_get_interface(msg), dbus_message_get_member(msg),
	                        dbus_message_get_path(msg)));

	            dbus_error_init(&err);

	            // DownloadFinished
	            if (dbus_message_is_signal(msg, DBUS_WebBrowser_DataCommSrv_IFC, "DownloadFinished")) {
	                int iOutRet, iDonwloadId;
	                const char *strSrcUrl, *strDestUrl;
	                if (dbus_message_get_args(msg, &err,
	                                          DBUS_TYPE_INT32, &iOutRet,
	                                          DBUS_TYPE_UINT32, &iDonwloadId,
	                                          DBUS_TYPE_STRING, &strSrcUrl,
	                                          DBUS_TYPE_STRING, &strDestUrl,
	                                          DBUS_TYPE_INVALID)) {
	                    DEBUGMSGTL(("DBus", "%s: iOutRet=%d iDonwloadId=%d strSrcUrl='%s' strDestUrl='%s'\n",
	                                __FUNCTION__, iOutRet, iDonwloadId, strSrcUrl, strDestUrl));
	                } else {
	                    LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, msg);
	                }

	            } else if (dbus_message_is_signal(msg, DBUS_WebBrowser_DataCommSrv_IFC, "tnetReady")) {
					//LOG_BLINE("send_tnetReady_trap\n");
	                send_tnetReady_trap();

	            } else if (dbus_message_is_signal(msg, DBUS_WebBrowser_DataCommSrv_IFC, "restartInitiated")) {

	                send_restartInitiated_trap();

	            } else if (dbus_message_is_signal(msg, DBUS_WebBrowser_DataCommSrv_IFC, "streamDetect")) {

	            } else if (dbus_message_is_signal(msg, DBUS_WebBrowser_DataCommSrv_IFC, "streamLoss")) {

	            } else if (dbus_message_is_signal(msg, DBUS_WebBrowser_DataCommSrv_IFC, "powerOff")) {

                } else if (dbus_message_is_signal(msg, DBUS_GpioBtnInput_IFC, "GpioInputInterrupt")) {

                    int keyNum, keyPress;
                    if (dbus_message_get_args(msg, &err,
                                              DBUS_TYPE_INT32, &keyNum,
                                              DBUS_TYPE_INT32, &keyPress,
                                              DBUS_TYPE_INVALID)) {
                        DEBUGMSGTL(("DBus", "signal %s: keyNum='%d' keyPress=%d\n", __FUNCTION__, keyNum, keyPress));
                        send_gpioInterrupt_trap(keyNum, keyPress);
                    } else {
                        LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, msg);
                    }

                } else if (dbus_message_is_signal(msg, DBUS_SystemService_NetworkManagerSrv_IFC, "WifiStatus")) {

                    const char *msgErr = "";
                    int status = -1;

                    if (!dbus_message_get_args(msg, &err,
                                               DBUS_TYPE_INT32, &status,
                                               DBUS_TYPE_STRING, &msgErr,
                                               DBUS_TYPE_INVALID)) {
                        LOG_AND_FREE_DBUS_ERROR_WITH_MSG(&err, msg);
                    } else {
                        DEBUGMSGTL(("DBus", "signal %s: status='%d', msgErr='%s'\n", __FUNCTION__, status, msgErr));
                        if (status == 0)
                            getWifiCfg();
                        send_wifiStatus_trap(status, msgErr);
                    }

                } else if (dbus_message_is_signal(msg, DBUS_OBJ_IF_SNMP_AGENT, DBUS_SIG_SnmpAgent_WakeupThread)) {
                    LOG_BLINE("WakeupThread\n");
                }
	        }
			dbus_message_unref(msg);
			msg = NULL;
		}
    }

lose:
	if(conn)
	{
		dbus_connection_close(conn);
		dbus_connection_unref(conn);
		conn = NULL;
	}
	
    return NULL;
}

INT_t TrapThread_WaitForFinished()
{
	INT_t iOutRet = ERROR_SUCCESS;
	int iRet;
	void * pRet = NULL;

	do
	{
		iRet = pthread_join(g_TrapThreadId, &pRet);
		if(0 == iRet)
		{
			LOG_BLINE("Thread(0x%08x) finished\n", (unsigned int)g_TrapThreadId);
		}
		else
		{
			PRINT_BFILE_LINENO_CRT_ERRINFO;
		}
		g_TrapThreadId = 0;
	}while(FALSE);

	return iOutRet;
}

void init_asTrap(void)
{
	int iRet;

	DEBUGMSGTL(("Trap", "init_asTrap\n"));

	do
	{
		if(g_TrapThreadId)
		{
			PRINT_BFILE_LINENO_BUG_STR;
			break;
		}

		g_bExitTrapThread = FALSE;
    	iRet = pthread_create(&g_TrapThreadId, NULL, HandleDBusSignalWorker, NULL);
		if(0 != iRet)
		{
			LOG_BLINE("CreateThread err %d\n", iRet);
			break;
		}
		/*
		//Not use pthread_detach if we prepare to use pthread_join
		if(0 < g_TrapThreadId)
		{
			iRet = pthread_detach(g_TrapThreadId);
			if(0 != iRet)
			{
				LOG_BLINE("DetachThread(%d) err %d\n", (int)g_TrapThreadId, iRet);
				break;
			}
		}
		*/
		DEBUGMSGTL(("Trap", "TrapThread started\n"));
	}while(FALSE);
}

void DeinitTrap(void)
{
	INT_t iRet;
	
	do
	{
		if(0 == g_TrapThreadId)
		{
			break;
		}
		g_bExitTrapThread = TRUE;
		//Wakeup the trap thread
		//LOG_BLINE("\n");
		iRet = SendDbusSig_WakeupThread();
		if(ERROR_SUCCESS != iRet)
		{
			PRINT_BFILE_LINENO_IRET_STR;
		}
		//LOG_BLINE("\n");
		iRet = TrapThread_WaitForFinished();
		if(ERROR_SUCCESS != iRet)
		{
			PRINT_BFILE_LINENO_IRET_STR;
		}
		//LOG_BLINE("\n");
	}while(FALSE);
}

